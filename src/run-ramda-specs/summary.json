{"F":{"method":"F","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('F', function() {\n  it('always returns false', function() {\n    eq(R.F(), false);\n    eq(R.F(10), false);\n    eq(R.F(true), false);\n  });"},"T":{"method":"T","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('T', function() {\n  it('always returns true', function() {\n    eq(R.T(), true);\n    eq(R.T(10), true);\n    eq(R.T(true), true);\n  });"},"add":{"method":"add","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\n\ndescribe('add', function() {\n  it('adds together two numbers', function() {\n    eq(R.add(3, 7), 10);\n  });\n  it('coerces its arguments to numbers', function() {\n    eq(R.add('1', '2'), 3);\n    eq(R.add(1, '2'), 3);\n    eq(R.add(true, false), 1);\n    eq(R.add(null, null), 0);\n    eq(R.add(undefined, undefined), NaN);\n    eq(R.add(new Date(1), new Date(2)), 3);\n  });\ndescribe('add properties', function() {\n  it('commutative', function() {\n    fc.assert(fc.property(fc.integer(), fc.integer(), function(a, b) {\n      return R.add(a, b) === R.add(b, a);\n    }));\n  });\n  it('associative', function() {\n    fc.assert(fc.property(fc.integer(), fc.integer(), fc.integer(), function(a, b, c) {\n      return R.add(a, R.add(b, c)) === R.add(R.add(a, b), c);\n    }));\n  });\n  it('identity', function() {\n    fc.assert(fc.property(fc.integer(), function(a) {\n      return R.add(a, 0) === a && R.add(0, a) === a;\n    }));\n  });"},"adjust":{"diffReason":"Ramda method accepts an array-like object","method":"adjust","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('adjust', function() {\n  it('applies the given function to the value at the given index of the supplied array', function() {\n    eq(R.adjust(2, R.add(1), [0, 1, 2, 3]), [0, 1, 3, 3]);\n  });\n  it('offsets negative indexes from the end of the array', function() {\n    eq(R.adjust(-3, R.add(1), [0, 1, 2, 3]), [0, 2, 2, 3]);\n  });\n  it('returns the original array if the supplied index is out of bounds', function() {\n    var list = [0, 1, 2, 3];\n    eq(R.adjust(4, R.add(1), list), list);\n    eq(R.adjust(-5, R.add(1), list), list);\n  });\n  it('does not mutate the original array', function() {\n    var list = [0, 1, 2, 3];\n    eq(R.adjust(2, R.add(1), list), [0, 1, 3, 3]);\n    eq(list, [0, 1, 2, 3]);\n  });\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.adjust(2, R.add(1), args(0, 1, 2, 3)), [0, 1, 3, 3]);\n  });"},"all":{"method":"all","content":"var listXf = require('./helpers/listXf');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('all', function() {\n  var even = function(n) {return n % 2 === 0;};\n  var T = function() {return true;};\n  var isFalse = function(x) { return x === false; };\n  var intoArray = R.into([]);\n  it('returns true if all elements satisfy the predicate', function() {\n    eq(R.all(even, [2, 4, 6, 8, 10, 12]), true);\n    eq(R.all(isFalse, [false, false, false]), true);\n  });\n  it('returns false if any element fails to satisfy the predicate', function() {\n    eq(R.all(even, [2, 4, 6, 8, 9, 10]), false);\n  });\n  it('returns true for an empty list', function() {\n    eq(R.all(T, []), true);\n  });\n  it('returns true into array if all elements satisfy the predicate', function() {\n    eq(intoArray(R.all(even), [2, 4, 6, 8, 10, 12]), [true]);\n    eq(intoArray(R.all(isFalse), [false, false, false]), [true]);\n  });\n  it('returns false into array if any element fails to satisfy the predicate', function() {\n    eq(intoArray(R.all(even), [2, 4, 6, 8, 9, 10]), [false]);\n  });\n  it('returns true into array for an empty list', function() {\n    eq(intoArray(R.all(T), []), [true]);\n  });\n  it('works with more complex objects', function() {\n    var xs = [{x: 'abc'}, {x: 'ade'}, {x: 'fghiajk'}];\n    function len3(o) { return o.x.length === 3; }\n    function hasA(o) { return o.x.indexOf('a') > -1; }\n    eq(R.all(len3, xs), false);\n    eq(R.all(hasA, xs), true);\n  });\n  it('dispatches when given a transformer in list position', function() {\n    eq(R.all(even, listXf), {\n      all: true,\n      f: even,\n      xf: listXf\n    });\n  });"},"allPass":{"diffReason":"Ramda method returns a curried function whose arity matches that of the highest-arity predicate","method":"allPass","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('allPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var lt20 = function(n) { return n < 20; };\n  var gt5 = function(n) { return n > 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('reports whether all predicates are satisfied by a given value', function() {\n    var ok = R.allPass([odd, lt20, gt5]);\n    eq(ok(7), true);\n    eq(ok(9), true);\n    eq(ok(10), false);\n    eq(ok(3), false);\n    eq(ok(21), false);\n  });\n  it('returns true on empty predicate list', function() {\n    eq(R.allPass([])(3), true);\n  });\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.allPass([odd, gt5, plusEq]).length, 4);\n    eq(R.allPass([odd, gt5, plusEq])(9, 9, 9, 9), true);\n    eq(R.allPass([odd, gt5, plusEq])(9)(9)(9)(9), true);\n  });"},"always":{"method":"always","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\n\ndescribe('always', function() {\n  it('returns a function that returns the object initially supplied', function() {\n    var theMeaning = R.always(42);\n    eq(theMeaning(), 42);\n    eq(theMeaning(10), 42);\n    eq(theMeaning(false), 42);\n  });\n  it('works with various types', function() {\n    eq(R.always(false)(), false);\n    eq(R.always('abc')(), 'abc');\n    eq(R.always({a: 1, b: 2})(), {a: 1, b: 2});\n    var obj = {a: 1, b: 2};\n    eq(R.always(obj)(), obj);\n    var now = new Date(1776, 6, 4);\n    eq(R.always(now)(), new Date(1776, 6, 4));\n    eq(R.always(undefined)(), undefined);\n  });\ndescribe('always properties', function() {\n  it('returns initial argument', function() {\n    fc.assert(fc.property(fc.anything(), fc.anything(), function(a, b) {\n      fc.pre(a === a);\n      var f = R.always(a);\n      return f() === a && f(b) === a;\n    }));\n  });"},"and":{"method":"and","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('and', function() {\n  it('compares two values with js &&', function() {\n    eq(R.and(true, true), true);\n    eq(R.and(true, false), false);\n    eq(R.and(false, true), false);\n    eq(R.and(false, false), false);\n  });"},"any":{"method":"any","content":"var listXf = require('./helpers/listXf');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('any', function() {\n  var odd = function(n) {return n % 2 === 1;};\n  var T = function() {return true;};\n  var intoArray = R.into([]);\n  it('returns true if any element satisfies the predicate', function() {\n    eq(R.any(odd, [2, 4, 6, 8, 10, 11, 12]), true);\n  });\n  it('returns false if all elements fails to satisfy the predicate', function() {\n    eq(R.any(odd, [2, 4, 6, 8, 10, 12]), false);\n  });\n  it('returns true into array if any element satisfies the predicate', function() {\n    eq(intoArray(R.any(odd), [2, 4, 6, 8, 10, 11, 12]), [true]);\n  });\n  it('returns false if all elements fails to satisfy the predicate', function() {\n    eq(intoArray(R.any(odd), [2, 4, 6, 8, 10, 12]), [false]);\n  });\n  it('works with more complex objects', function() {\n    var people = [{first: 'Paul', last: 'Grenier'}, {first:'Mike', last: 'Hurley'}, {first: 'Will', last: 'Klein'}];\n    var alliterative = function(person) {return person.first.charAt(0) === person.last.charAt(0);};\n    eq(R.any(alliterative, people), false);\n    people.push({first: 'Scott', last: 'Sauyet'});\n    eq(R.any(alliterative, people), true);\n  });\n  it('can use a configurable function', function() {\n    var teens = [{name: 'Alice', age: 14}, {name: 'Betty', age: 18}, {name: 'Cindy', age: 17}];\n    var atLeast = function(age) {return function(person) {return person.age >= age;};};\n    eq(R.any(atLeast(16), teens), true);\n    eq(R.any(atLeast(21), teens), false);\n  });\n  it('returns false for an empty list', function() {\n    eq(R.any(T, []), false);\n  });\n  it('returns false into array for an empty list', function() {\n    eq(intoArray(R.any(T), []), [false]);\n  });\n  it('dispatches when given a transformer in list position', function() {\n    eq(R.any(odd, listXf), {\n      any: false,\n      f: odd,\n      xf: listXf\n    });\n  });"},"anyPass":{"diffReason":"Ramda method returns a curried function whose arity matches that of the highest-arity predicate","method":"anyPass","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('anyPass', function() {\n  var odd = function(n) { return n % 2 !== 0; };\n  var gt20 = function(n) { return n > 20; };\n  var lt5 = function(n) { return n < 5; };\n  var plusEq = function(w, x, y, z) { return w + x === y + z; };\n  it('reports whether any predicates are satisfied by a given value', function() {\n    var ok = R.anyPass([odd, gt20, lt5]);\n    eq(ok(7), true);\n    eq(ok(9), true);\n    eq(ok(10), false);\n    eq(ok(18), false);\n    eq(ok(3), true);\n    eq(ok(22), true);\n  });\n  it('returns false for an empty predicate list', function() {\n    eq(R.anyPass([])(3), false);\n  });\n  it('returns a curried function whose arity matches that of the highest-arity predicate', function() {\n    eq(R.anyPass([odd, lt5, plusEq]).length, 4);\n    eq(R.anyPass([odd, lt5, plusEq])(6, 7, 8, 9), false);\n    eq(R.anyPass([odd, lt5, plusEq])(6)(7)(8)(9), false);\n  });"},"append":{"method":"append","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('append', function() {\n  it('adds the element to the end of the list', function() {\n    eq(R.append('z', ['x', 'y']), ['x', 'y', 'z']);\n    eq(R.append(['a', 'z'], ['x', 'y']), ['x', 'y', ['a', 'z']]);\n  });\n  it('works on empty list', function() {\n    eq(R.append(1, []), [1]);\n  });"},"applySpec":{"method":"applySpec","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('applySpec', function() {\n  it('works with empty spec', function() {\n    eq(R.applySpec({})(), {});\n  });\n  it('works with unary functions', function() {\n    eq(R.applySpec({ v: R.inc, u: R.dec })(1), { v: 2, u: 0 });\n  });\n  it('works with binary functions', function() {\n    eq(R.applySpec({ sum: R.add })(1, 2), { sum: 3 });\n  });\n  it('works with nested specs', function() {\n    eq(R.applySpec({ unnested: R.always(0), nested: { sum: R.add } })(1, 2),\n      { unnested: 0, nested: { sum: 3 } }\n    );\n  });\n  it('works with arrays of nested specs', function() {\n    eq(R.applySpec({ unnested: R.always(0), nested:[{ sum: R.add }] })(1, 2),\n      { unnested: 0, nested: [{ sum: 3 }] }\n    );\n  });\n  it('works with arrays of spec objects', function() {\n    eq(R.applySpec([{ sum: R.add }])(1, 2),\n      [{ sum: 3 }]\n    );\n  });\n  it('works with arrays of functions', function() {\n    eq(R.applySpec([R.map(R.prop('a')), R.map(R.prop('b'))])([\n      {a: 'a1', b: 'b1'}, {a: 'a2', b: 'b2'}\n    ]),\n    [['a1', 'a2'], ['b1', 'b2']]);\n  });\n  it('works with a spec defining a map key', function() {\n    eq(R.applySpec({map: R.prop('a')})({a: 1}), {map: 1});\n  });\n  it('retains the highest arity', function() {\n    var f = R.applySpec({ f1: R.nAry(2, R.T), f2: R.nAry(5, R.T) });\n    eq(f.length, 5);\n  });\n  it('returns a curried function', function() {\n    eq(R.applySpec({ sum: R.add })(1)(2), { sum: 3 });\n  });"},"assoc":{"method":"assoc","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('assoc', function() {\n  it('makes a shallow clone of an object, overriding only the specified property', function() {\n    var obj1 = {a: 1, b: {c: 2, d: 3}, e: 4, f: 5};\n    var obj2 = R.assoc('e', {x: 42}, obj1);\n    eq(obj2, {a: 1, b: {c: 2, d: 3}, e: {x: 42}, f: 5});\n    // Note: reference equality below!\n    assert.strictEqual(obj2.a, obj1.a);\n    assert.strictEqual(obj2.b, obj1.b);\n    assert.strictEqual(obj2.f, obj1.f);\n  });\n  it('is the equivalent of clone and set if the property is not on the original', function() {\n    var obj1 = {a: 1, b: {c: 2, d: 3}, e: 4, f: 5};\n    var obj2 = R.assoc('z', {x: 42}, obj1);\n    eq(obj2, {a: 1, b: {c: 2, d: 3}, e: 4, f: 5, z: {x: 42}});\n    // Note: reference equality below!\n    assert.strictEqual(obj2.a, obj1.a);\n    assert.strictEqual(obj2.b, obj1.b);\n    assert.strictEqual(obj2.f, obj1.f);\n  });\n  it('makes a shallow clone of an array, overriding only the specified index', function() {\n    var newValue = [4, 2];\n    var ary1 = [1, [2, 3], 4, 5];\n    var ary2 = R.assoc(2, newValue, ary1);\n    eq(ary2, [1, [2, 3], [4, 2], 5]);\n    // Note: reference equality below!\n    assert.strictEqual(ary2[0], ary1[0]);\n    assert.strictEqual(ary2[1], ary1[1]);\n    assert.strictEqual(ary2[2], newValue);\n    assert.strictEqual(ary2[3], ary1[3]);\n  });\n  it('is the equivalent of clone and set if the index is not on the original', function() {\n    var newValue = [4, 2];\n    var ary1 = [1, [2, 3], 4];\n    var ary2 = R.assoc(5, newValue, ary1);\n    eq(ary2, [1, [2, 3], 4, undefined, undefined, [4, 2]]);\n    // Note: reference equality below!\n    assert.strictEqual(ary2[0], ary1[0]);\n    assert.strictEqual(ary2[1], ary1[1]);\n    assert.strictEqual(ary2[2], ary1[2]);\n    assert.strictEqual(ary2[5], newValue);\n  });"},"assocPath":{"method":"assocPath","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('assocPath', function() {\n  it('makes a shallow clone of an object, overriding only what is necessary for the path', function() {\n    var obj1 = {a: {b: 1, c: 2, d: {e: 3}}, f: {g: {h: 4, i: [5, 6, 7], j: {k: 6, l: 7}}}, m: 8};\n    var obj2 = R.assocPath(['f', 'g', 'i', 1], 42, obj1);\n    eq(obj2.f.g.i, [5, 42, 7]);\n    // Note: reference equality below!\n    assert.strictEqual(obj2.a, obj1.a);\n    assert.strictEqual(obj2.m, obj1.m);\n    assert.strictEqual(obj2.f.g.h, obj1.f.g.h);\n    assert.strictEqual(obj2.f.g.j, obj1.f.g.j);\n  });\n  it('is the equivalent of clone and setPath if the property is not on the original', function() {\n    var obj1 = {a: 1, b: {c: 2, d: 3}, e: 4, f: 5};\n    var obj2 = R.assocPath(['x', 0, 'y'], 42, obj1);\n    eq(obj2, {a: 1, b: {c: 2, d: 3}, e: 4, f: 5, x: [{y: 42}]});\n    // Note: reference equality below!\n    assert.strictEqual(obj2.a, obj1.a);\n    assert.strictEqual(obj2.b, obj1.b);\n    assert.strictEqual(obj2.e, obj1.e);\n    assert.strictEqual(obj2.f, obj1.f);\n  });\n  it('empty path replaces the the whole object', function() {\n    eq(R.assocPath([], 3, {a: 1, b: 2}), 3);\n  });\n  it('replaces `undefined` with a new object', function() {\n    eq(R.assocPath(['foo', 'bar', 'baz'], 42, {foo: undefined}), {foo: {bar: {baz: 42}}});\n  });\n  it('replaces `null` with a new object', function() {\n    eq(R.assocPath(['foo', 'bar', 'baz'], 42, {foo: null}), {foo: {bar: {baz: 42}}});\n  });"},"both":{"diffReason":"Ramda library supports fantasy-land","method":"both","content":"var S = require('sanctuary');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('both', function() {\n  it('combines two boolean-returning functions into one', function() {\n    var even = function(x) {return x % 2 === 0;};\n    var gt10 = function(x) {return x > 10;};\n    var f = R.both(even, gt10);\n    eq(f(8), false);\n    eq(f(13), false);\n    eq(f(14), true);\n  });\n  it('accepts functions that take multiple parameters', function() {\n    var between = function(a, b, c) {return a < b && b < c;};\n    var total20 = function(a, b, c) {return a + b + c === 20;};\n    var f = R.both(between, total20);\n    eq(f(4, 5, 11), true);\n    eq(f(12, 2, 6), false);\n    eq(f(5, 6, 15), false);\n  });\n  it('does not evaluate the second expression if the first one is false', function() {\n    var F = function() { return false; };\n    var Z = function() { effect = 'Z got evaluated'; };\n    var effect = 'not evaluated';\n    R.both(F, Z)();\n    eq(effect, 'not evaluated');\n  });\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.both(Just(true), Just(true)), Just(true));\n    eq(R.both(Just(true), Just(false)), Just(false));\n    eq(R.both(Just(true), Nothing()), Nothing());\n    eq(R.both(Nothing(), Just(false)), Nothing());\n    eq(R.both(Nothing(), Nothing()), Nothing());\n  });"},"chain":{"diffReason":"Ramda method passes to `chain` property if available | Ramda library supports fantasy-land","method":"chain","content":"var listXf = require('./helpers/listXf');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar _isTransformer = require('rambda/internal/_isTransformer');\ndescribe('chain', function() {\n  var intoArray = R.into([]);\n  function add1(x) { return [x + 1]; }\n  function dec(x) { return [x - 1]; }\n  function times2(x) { return [x * 2]; }\n  it('maps a function over a nested list and returns the (shallow) flattened result', function() {\n    eq(R.chain(times2, [1, 2, 3, 1, 0, 10, -3, 5, 7]), [2, 4, 6, 2, 0, 20, -6, 10, 14]);\n    eq(R.chain(times2, [1, 2, 3]), [2, 4, 6]);\n  });\n  it('does not flatten recursively', function() {\n    function f(xs) {\n      return xs[0] ? [xs[0]] : [];\n    }\n    eq(R.chain(f, [[1], [[2], 100], [], [3, [4]]]), [1, [2], 3]);\n  });\n  it('maps a function (a -> [b]) into a (shallow) flat result', function() {\n    eq(intoArray(R.chain(times2), [1, 2, 3, 4]), [2, 4, 6, 8]);\n  });\n  it('interprets ((->) r) as a monad', function() {\n    var h = function(r) { return r * 2; };\n    var f = function(a) {\n      return function(r) {\n        return r + a;\n      };\n    };\n    var bound = R.chain(f, h);\n    // (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)\n    // h >>= f = \\w -> f (h w) w\n    eq(bound(10), (10 * 2) + 10);\n    eq(R.chain(R.append, R.head)([1, 2, 3]), [1, 2, 3, 1]);\n  });\n  it('dispatches to objects that implement `chain`', function() {\n    var obj = {x: 100, chain: function(f) { return f(this.x); }};\n    eq(R.chain(add1, obj), [101]);\n  });\n  it('dispatches to transformer objects', function() {\n    eq(_isTransformer(R.chain(add1, listXf)), true);\n  });\n  it('composes', function() {\n    var mdouble = R.chain(times2);\n    var mdec = R.chain(dec);\n    eq(mdec(mdouble([10, 20, 30])), [19, 39, 59]);\n  });\n  it('can compose transducer-style', function() {\n    var mdouble = R.chain(times2);\n    var mdec = R.chain(dec);\n    var xcomp = R.compose(mdec, mdouble);\n    eq(intoArray(xcomp, [10, 20, 30]), [18, 38, 58]);\n  });"},"clamp":{"method":"clamp","content":"var eq = require('./shared/eq');\nvar R = require('../../../../../rambda/dist/rambda');\n\ndescribe('clamp', function() {\n  it('clamps to the lower bound', function() {\n    eq(R.clamp(1, 10, 0), 1);\n    eq(R.clamp(3, 12, 1), 3);\n    eq(R.clamp(-15, 3, -100), -15);\n  });\n  it('clamps to the upper bound', function() {\n    eq(R.clamp(1, 10, 20), 10);\n    eq(R.clamp(3, 12, 23), 12);\n    eq(R.clamp(-15, 3, 16), 3);\n  });\n  it('leaves it alone when within the bound', function() {\n    eq(R.clamp(1, 10, 4), 4);\n    eq(R.clamp(3, 12, 6), 6);\n    eq(R.clamp(-15, 3, 0), 0);\n  });\n  it('works with letters as well', function() {\n    eq(R.clamp('d', 'n', 'f'), 'f');\n    eq(R.clamp('d', 'n', 'a'), 'd');\n    eq(R.clamp('d', 'n', 'q'), 'n');\n  });"},"clone":{"diffReason":"Rambda method work only with objects and arrays","method":"clone","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('deep clone integers, strings and booleans', function() {\n  it('clones integers', function() {\n    eq(R.clone(-4), -4);\n    eq(R.clone(9007199254740991), 9007199254740991);\n  });\n  it('clones floats', function() {\n    eq(R.clone(-4.5), -4.5);\n    eq(R.clone(0.0), 0.0);\n  });\n  it('clones strings', function() {\n    eq(R.clone('ramda'), 'ramda');\n  });\n  it('clones booleans', function() {\n    eq(R.clone(true), true);\n  });\ndescribe('deep clone objects', function() {\n  it('clones shallow object', function() {\n    var obj = {a: 1, b: 'ramda', c: true, d: new Date(2013, 11, 25)};\n    var clone = R.clone(obj);\n    obj.c = false;\n    obj.d.setDate(31);\n    eq(clone, {a: 1, b: 'ramda', c: true, d: new Date(2013, 11, 25)});\n  });\n  it('clones deep object', function() {\n    var obj = {a: {b: {c: 'ramda'}}};\n    var clone = R.clone(obj);\n    obj.a.b.c = null;\n    eq(clone, {a: {b: {c: 'ramda'}}});\n  });\n  it('clones objects with circular references', function() {\n    var x = {c: null};\n    var y = {a: x};\n    var z = {b: y};\n    x.c = z;\n    var clone = R.clone(x);\n    assert.notStrictEqual(x, clone);\n    assert.notStrictEqual(x.c, clone.c);\n    assert.notStrictEqual(x.c.b, clone.c.b);\n    assert.notStrictEqual(x.c.b.a, clone.c.b.a);\n    assert.notStrictEqual(x.c.b.a.c, clone.c.b.a.c);\n    eq(R.keys(clone), R.keys(x));\n    eq(R.keys(clone.c), R.keys(x.c));\n    eq(R.keys(clone.c.b), R.keys(x.c.b));\n    eq(R.keys(clone.c.b.a), R.keys(x.c.b.a));\n    eq(R.keys(clone.c.b.a.c), R.keys(x.c.b.a.c));\n    x.c.b = 1;\n    assert.notDeepEqual(clone.c.b, x.c.b);\n  });\n  it('clone instances', function() {\n    var Obj = function(x) {\n      this.x = x;\n    };\n    Obj.prototype.get = function() {\n      return this.x;\n    };\n    Obj.prototype.set = function(x) {\n      this.x = x;\n    };\n    var obj = new Obj(10);\n    eq(obj.get(), 10);\n    var clone = R.clone(obj);\n    eq(clone.get(), 10);\n    assert.notStrictEqual(obj, clone);\n    obj.set(11);\n    eq(obj.get(), 11);\n    eq(clone.get(), 10);\n  });\n  it('only own properties be copied', function() {\n    function Obj() {\n      this.x = 'own property';\n    }\n    Obj.prototype = {\n      y: 'not own property'\n    };\n    const obj = new Obj();\n    const cloneObj = R.clone(obj);\n    eq(Object.keys(obj), Object.keys(cloneObj));\n  });\n  it('the prototype should keep the same', function() {\n    function Obj() {}\n    Obj.prototype = {\n      x: 'prototype property'\n    };\n    const obj = new Obj();\n    const cloneObj = R.clone(obj);\n    eq(Object.getPrototypeOf(obj), Object.getPrototypeOf(cloneObj));\n  });\n});\ndescribe('deep clone arrays', function() {\n  it('clones shallow arrays', function() {\n    var list = [1, 2, 3];\n    var clone = R.clone(list);\n    list.pop();\n    eq(clone, [1, 2, 3]);\n  });\n  it('clones deep arrays', function() {\n    var list = [1, [1, 2, 3], [[[5]]]];\n    var clone = R.clone(list);\n    assert.notStrictEqual(list, clone);\n    assert.notStrictEqual(list[2], clone[2]);\n    assert.notStrictEqual(list[2][0], clone[2][0]);\n    eq(clone, [1, [1, 2, 3], [[[5]]]]);\n  });\n});\ndescribe('deep clone typed arrays', function() {\n  it('clones Uint16Array', function() {\n    var array = new Uint16Array([1, 2, 3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Uint16Array([1, 2, 3]));\n  });\n  it('clones Int8Array', function() {\n    var array = new Int8Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Int8Array([1,2,3]));\n  });\n  it('clones Uint8Array', function() {\n    var array = new Uint8Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Uint8Array([1,2,3]));\n  });\n  it('clones Uint8ClampedArray', function() {\n    var array = new Uint8ClampedArray([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Uint8ClampedArray([1,2,3]));\n  });\n  it('clones Int16Array', function() {\n    var array = new Int16Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Int16Array([1,2,3]));\n  });\n  it('clones Uint16Array', function() {\n    var array = new Uint16Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Uint16Array([1,2,3]));\n  });\n  it('clones Int32Array', function() {\n    var array = new Int32Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Int32Array([1,2,3]));\n  });\n  it('clones Uint32Array', function() {\n    var array = new Uint32Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Uint32Array([1,2,3]));\n  });\n  it('clones Float32Array', function() {\n    var array = new Float32Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Float32Array([1,2,3]));\n  });\n  it('clones Float64Array', function() {\n    var array = new Float64Array([1,2,3]);\n    var clone = R.clone(array);\n    assert.notStrictEqual(array, clone);\n    eq(clone, new Float64Array([1,2,3]));\n  });\n});\ndescribe('deep clone functions', function() {\n  it('keep reference to function', function() {\n    var fn = function(x) { return x + x;};\n    var list = [{a: fn}];\n    var clone = R.clone(list);\n    eq(clone[0].a(10), 20);\n    eq(list[0].a, clone[0].a);\n  });\n});\ndescribe('built-in types', function() {\n  it('clones Date object', function() {\n    var date = new Date(2014, 10, 14, 23, 59, 59, 999);\n    var clone = R.clone(date);\n    assert.notStrictEqual(date, clone);\n    eq(clone, new Date(2014, 10, 14, 23, 59, 59, 999));\n    eq(clone.getDay(), 5); // friday\n  });\n  it('clones RegExp object', function() {\n    R.forEach(function(pattern) {\n      var clone = R.clone(pattern);\n      assert.notStrictEqual(clone, pattern);\n      eq(clone.constructor, RegExp);\n      eq(clone.source, pattern.source);\n      eq(clone.global, pattern.global);\n      eq(clone.ignoreCase, pattern.ignoreCase);\n      eq(clone.multiline, pattern.multiline);\n    }, [/x/, /x/g, /x/i, /x/m, /x/gi, /x/gm, /x/im, /x/gim]);\n  });\n});\ndescribe('deep clone deep nested mixed objects', function() {\n  it('clones array with objects', function() {\n    var list = [{a: {b: 1}}, [{c: {d: 1}}]];\n    var clone = R.clone(list);\n    list[1][0] = null;\n    eq(clone, [{a: {b: 1}}, [{c: {d: 1}}]]);\n  });\n  it('clones array with arrays', function() {\n    var list = [[1], [[3]]];\n    var clone = R.clone(list);\n    list[1][0] = null;\n    eq(clone, [[1], [[3]]]);\n  });\n  it('clones array with mutual ref object', function() {\n    var obj = {a: 1};\n    var list = [{b: obj}, {b: obj}];\n    var clone = R.clone(list);\n    assert.strictEqual(list[0].b, list[1].b);\n    assert.strictEqual(clone[0].b, clone[1].b);\n    assert.notStrictEqual(clone[0].b, list[0].b);\n    assert.notStrictEqual(clone[1].b, list[1].b);\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n    obj.a = 2;\n    eq(clone[0].b, {a:1});\n    eq(clone[1].b, {a:1});\n  });\n});\ndescribe('deep clone edge cases', function() {\n  it('nulls, undefineds and empty objects and arrays', function() {\n    eq(R.clone(null), null);\n    eq(R.clone(undefined), undefined);\n    assert.notStrictEqual(R.clone(undefined), null);\n    var obj = {};\n    assert.notStrictEqual(R.clone(obj), obj);\n    var list = [];\n    assert.notStrictEqual(R.clone(list), list);\n  });\n});\ndescribe('Let `R.clone` use an arbitrary user defined `clone` method', function() {\n  it('dispatches to `clone` method if present', function() {\n    function ArbitraryClone(x) { this.value = x; }\n    ArbitraryClone.prototype.clone = function() { return new ArbitraryClone(this.value); };\n    var obj = new ArbitraryClone(42);\n    var arbitraryClonedObj = R.clone(obj);\n    eq(arbitraryClonedObj, new ArbitraryClone(42));\n    eq(arbitraryClonedObj instanceof ArbitraryClone, true);\n  });\n});"},"complement":{"diffReason":"Ramda library supports fantasy-land","method":"complement","content":"var S = require('sanctuary');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('complement', function() {\n  it('creates boolean-returning function that reverses another', function() {\n    var even = function(x) {return x % 2 === 0;};\n    var f = R.complement(even);\n    eq(f(8), false);\n    eq(f(13), true);\n  });\n  it('accepts a function that take multiple parameters', function() {\n    var between = function(a, b, c) {return a < b && b < c;};\n    var f = R.complement(between);\n    eq(f(4, 5, 11), false);\n    eq(f(12, 2, 6), true);\n  });\n  it('accepts fantasy-land functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.complement(Just(true)), Just(false));\n    eq(R.complement(Just(false)), Just(true));\n    eq(R.complement(Nothing()), Nothing());\n  });"},"compose":{"diffReason":"Ramda method passes context to functions | Rambda composed functions have no length","method":"compose","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\ndescribe('compose', function() {\n  it('is a variadic function', function() {\n    eq(typeof R.compose, 'function');\n    eq(R.compose.length, 0);\n  });\n  it('performs right-to-left function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.compose(R.map, R.multiply, parseInt);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.compose(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('throws if given no arguments', function() {\n    assert.throws(\n      function() { R.compose(); },\n      function(err) {\n        return err.constructor === Error &&\n               err.message === 'compose requires at least one argument';\n      }\n    );\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.compose(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });\ndescribe('compose properties', function() {\n  it('composes two functions', function() {\n    fc.assert(fc.property(fc.func(fc.nat()), fc.func(fc.nat()), fc.nat(), function(f, g, x) {\n      return R.equals(R.compose(f, g)(x), f(g(x)));\n    }));\n  });\n  it('associative', function() {\n    fc.assert(fc.property(fc.func(fc.nat()), fc.func(fc.nat()), fc.func(fc.nat()), fc.nat(), function(f, g, h, x) {\n      var result = f(g(h(x)));\n      return R.all(R.equals(result), [\n        R.compose(f, g, h)(x),\n        R.compose(f, R.compose(g, h))(x),\n        R.compose(R.compose(f, g), h)(x)\n      ]);\n    }));\n  });"},"concat":{"diffReason":"Ramda method pass to `concat` property if present","method":"concat","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('concat', function() {\n  var z1 = {\n    x: 'z1',\n    concat: function(that) { return this.x + ' ' + that.x; }\n  };\n  var z2 = {\n    x: 'z2'\n  };\n  it('adds combines the elements of the two lists', function() {\n    eq(R.concat(['a', 'b'], ['c', 'd']), ['a', 'b', 'c', 'd']);\n    eq(R.concat([], ['c', 'd']), ['c', 'd']);\n  });\n  it('works on strings', function() {\n    eq(R.concat('foo', 'bar'), 'foobar');\n    eq(R.concat('x', ''), 'x');\n    eq(R.concat('', 'x'), 'x');\n    eq(R.concat('', ''), '');\n  });\n  it('delegates to non-String object with a concat method, as second param', function() {\n    eq(R.concat(z1, z2), 'z1 z2');\n  });\n  it('throws if attempting to combine an array with a non-array', function() {\n    assert.throws(function() { return R.concat([1], 2); }, TypeError);\n  });\n  it('throws if not an array, String, or object with a concat method', function() {\n    assert.throws(function() { return R.concat({}, {}); }, TypeError);\n  });"},"cond":{"diffReason":"pass to transformer is not applied in Rambda method","method":"cond","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('cond', function() {\n  it('returns a function', function() {\n    eq(typeof R.cond([]), 'function');\n  });\n  it('returns a conditional function', function() {\n    var fn = R.cond([\n      [R.equals(0),   R.always('water freezes at 0°C')],\n      [R.equals(100), R.always('water boils at 100°C')],\n      [R.T,           function(temp) { return 'nothing special happens at ' + temp + '°C'; }]\n    ]);\n    eq(fn(0), 'water freezes at 0°C');\n    eq(fn(50), 'nothing special happens at 50°C');\n    eq(fn(100), 'water boils at 100°C');\n  });\n  it('returns a function which returns undefined if none of the predicates matches', function() {\n    var fn = R.cond([\n      [R.equals('foo'), R.always(1)],\n      [R.equals('bar'), R.always(2)]\n    ]);\n    eq(fn('quux'), undefined);\n  });\n  it('predicates are tested in order', function() {\n    var fn = R.cond([\n      [R.T, R.always('foo')],\n      [R.T, R.always('bar')],\n      [R.T, R.always('baz')]\n    ]);\n    eq(fn(), 'foo');\n  });\n  it('forwards all arguments to predicates and to transformers', function() {\n    var fn = R.cond([\n      [function(_, x) { return x === 42; }, function() { return arguments.length; }]\n    ]);\n    eq(fn(21, 42, 84), 3);\n  });\n  it('retains highest predicate arity', function() {\n    var fn = R.cond([\n      [R.nAry(2, R.T), R.T],\n      [R.nAry(3, R.T), R.T],\n      [R.nAry(1, R.T), R.T]\n    ]);\n    eq(fn.length, 3);\n  });"},"converge":{"method":"converge","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('converge', function() {\n  var mult = function(a, b) {return a * b;};\n  var f1 = R.converge(mult, [\n    function(a) { return a; },\n    function(a) { return a; }\n  ]);\n  var f2 = R.converge(mult, [\n    function(a) { return a; },\n    function(a, b) { return b; }\n  ]);\n  var f3 = R.converge(mult, [\n    function(a) { return a; },\n    function(a, b, c) { return c; }\n  ]);\n  it('passes the results of applying the arguments individually to two separate functions into a single one', function() {\n    eq(R.converge(mult, [R.add(1), R.add(3)])(2), 15); // mult(add1(2), add3(2)) = mult(3, 5) = 3 * 15;\n  });\n  it('returns a function with the length of the \"longest\" argument', function() {\n    eq(f1.length, 1);\n    eq(f2.length, 2);\n    eq(f3.length, 3);\n  });\n  it('passes context to its functions', function() {\n    var a = function(x) { return this.f1(x); };\n    var b = function(x) { return this.f2(x); };\n    var c = function(x, y) { return this.f3(x, y); };\n    var d = R.converge(c, [a, b]);\n    var context = {f1: R.add(1), f2: R.add(2), f3: R.add};\n    eq(a.call(context, 1), 2);\n    eq(b.call(context, 1), 3);\n    eq(d.call(context, 1), 5);\n  });\n  it('returns a curried function', function() {\n    eq(f2(6)(7), 42);\n    eq(f3(R.__).length, 3);\n  });\n  it('works with empty functions list', function() {\n    var fn = R.converge(function() { return arguments.length; }, []);\n    eq(fn.length, 0);\n    eq(fn(), 0);\n  });"},"curry":{"diffReason":"Ramda library support placeholder(R.__)","method":"curry","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\n\ndescribe('curry', function() {\n  it('curries a single value', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;}); // f(12, 3, 6, 2) == 15\n    var g = f(12);\n    eq(g(3, 6, 2), 15);\n  });\n  it('curries multiple values', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;}); // f(12, 3, 6, 2) == 15\n    var g = f(12, 3);\n    eq(g(6, 2), 15);\n    var h = f(12, 3, 6);\n    eq(h(2), 15);\n  });\n  it('allows further currying of a curried function', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;}); // f(12, 3, 6, 2) == 15\n    var g = f(12);\n    eq(g(3, 6, 2), 15);\n    var h = g(3);\n    eq(h(6, 2), 15);\n    eq(g(3, 6)(2), 15);\n  });\n  it('properly reports the length of the curried function', function() {\n    var f = R.curry(function(a, b, c, d) {return (a + b * c) / d;});\n    eq(f.length, 4);\n    var g = f(12);\n    eq(g.length, 3);\n    var h = g(3);\n    eq(h.length, 2);\n    eq(g(3, 6).length, 1);\n  });\n  it('preserves context', function() {\n    var ctx = {x: 10};\n    var f = function(a, b) { return a + b * this.x; };\n    var g = R.curry(f);\n    eq(g.call(ctx, 2, 4), 42);\n    eq(g.call(ctx, 2).call(ctx, 4), 42);\n  });\n  it('supports R.__ placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = R.__;\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('supports @@functional/placeholder', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.curry(f);\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('forwards extra arguments', function() {\n    var f = function(a, b, c) {\n      void c;\n      return Array.prototype.slice.call(arguments);\n    };\n    var g = R.curry(f);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(1, 2, 3, 4), [1, 2, 3, 4]);\n    eq(g(1, 2)(3, 4), [1, 2, 3, 4]);\n    eq(g(1)(2, 3, 4), [1, 2, 3, 4]);\n    eq(g(1)(2)(3, 4), [1, 2, 3, 4]);\n  });\n});\ndescribe('curry properties', function() {\n  it('curries multiple values', function() {\n    fc.assert(fc.property(fc.func(fc.anything()), fc.anything(), fc.anything(), fc.anything(), fc.anything(), function(f, a, b, c, d) {\n      var f4 = function(a, b, c, d) {\n        return f(a, b, c, d);\n      };\n      var g = R.curry(f4);\n      return R.all(R.equals(f4(a, b, c, d)), [\n        g(a, b, c, d),\n        g(a)(b)(c)(d),\n        g(a)(b, c, d),\n        g(a, b)(c, d),\n        g(a, b, c)(d)\n      ]);\n    }));\n  });\n  it('curries with placeholder', function() {\n    fc.assert(fc.property(fc.func(fc.anything()), fc.anything(), fc.anything(), fc.anything(), function(f, a, b, c) {\n      var _ = {'@@functional/placeholder': true, x: Math.random()};\n      var f3 = function(a, b, c) {\n        return f(a, b, c);\n      };\n      var g = R.curry(f3);\n      return R.all(R.equals(f3(a, b, c)), [\n        g(_, _, c)(a, b),\n        g(a, _, c)(b),\n        g(_, b, c)(a),\n        g(a, _, _)(_, c)(b),\n        g(a, b, _)(c)\n      ]);\n    }));\n  });\n});"},"curryN":{"method":"curryN","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('curryN', function() {\n  function source(a, b, c, d) {\n    void d;\n    return a * b * c;\n  }\n  it('accepts an arity', function() {\n    var curried = R.curryN(3, source);\n    eq(curried(1)(2)(3), 6);\n    eq(curried(1, 2)(3), 6);\n    eq(curried(1)(2, 3), 6);\n    eq(curried(1, 2, 3), 6);\n  });\n  it('can be partially applied', function() {\n    var curry3 = R.curryN(3);\n    var curried = curry3(source);\n    eq(curried.length, 3);\n    eq(curried(1)(2)(3), 6);\n    eq(curried(1, 2)(3), 6);\n    eq(curried(1)(2, 3), 6);\n    eq(curried(1, 2, 3), 6);\n  });\n  it('preserves context', function() {\n    var ctx = {x: 10};\n    var f = function(a, b) { return a + b * this.x; };\n    var g = R.curryN(2, f);\n    eq(g.call(ctx, 2, 4), 42);\n    eq(g.call(ctx, 2).call(ctx, 4), 42);\n  });\n  it('supports R.__ placeholder', function() {\n    var f = function() { return Array.prototype.slice.call(arguments); };\n    var g = R.curryN(3, f);\n    var _ = R.__;\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('supports @@functional/placeholder', function() {\n    var f = function() { return Array.prototype.slice.call(arguments); };\n    var g = R.curryN(3, f);\n    var _ = {'@@functional/placeholder': true, x: Math.random()};\n    eq(g(1)(2)(3), [1, 2, 3]);\n    eq(g(1)(2, 3), [1, 2, 3]);\n    eq(g(1, 2)(3), [1, 2, 3]);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(_, 2, 3)(1), [1, 2, 3]);\n    eq(g(1, _, 3)(2), [1, 2, 3]);\n    eq(g(1, 2, _)(3), [1, 2, 3]);\n    eq(g(1, _, _)(2)(3), [1, 2, 3]);\n    eq(g(_, 2, _)(1)(3), [1, 2, 3]);\n    eq(g(_, _, 3)(1)(2), [1, 2, 3]);\n    eq(g(1, _, _)(2, 3), [1, 2, 3]);\n    eq(g(_, 2, _)(1, 3), [1, 2, 3]);\n    eq(g(_, _, 3)(1, 2), [1, 2, 3]);\n    eq(g(1, _, _)(_, 3)(2), [1, 2, 3]);\n    eq(g(_, 2, _)(_, 3)(1), [1, 2, 3]);\n    eq(g(_, _, 3)(_, 2)(1), [1, 2, 3]);\n    eq(g(_, _, _)(_, _)(_)(1, 2, 3), [1, 2, 3]);\n    eq(g(_, _, _)(1, _, _)(_, _)(2, _)(_)(3), [1, 2, 3]);\n  });\n  it('forwards extra arguments', function() {\n    var f = function() { return Array.prototype.slice.call(arguments); };\n    var g = R.curryN(3, f);\n    eq(g(1, 2, 3), [1, 2, 3]);\n    eq(g(1, 2, 3, 4), [1, 2, 3, 4]);\n    eq(g(1, 2)(3, 4), [1, 2, 3, 4]);\n    eq(g(1)(2, 3, 4), [1, 2, 3, 4]);\n    eq(g(1)(2)(3, 4), [1, 2, 3, 4]);\n  });\n});"},"dec":{"method":"dec","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('dec', function() {\n  it('decrements its argument', function() {\n    eq(R.dec(-1), -2);\n    eq(R.dec(0), -1);\n    eq(R.dec(1), 0);\n    eq(R.dec(12.34), 11.34);\n    eq(R.dec(-Infinity), -Infinity);\n    eq(R.dec(Infinity), Infinity);\n  });"},"defaultTo":{"method":"defaultTo","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('defaultTo', function() {\n  var defaultTo42 = R.defaultTo(42);\n  it('returns the default value if input is null, undefined or NaN', function() {\n    eq(42, defaultTo42(null));\n    eq(42, defaultTo42(undefined));\n    eq(42, defaultTo42(NaN));\n  });\n  it('returns the input value if it is not null/undefined', function() {\n    eq('a real value', defaultTo42('a real value'));\n  });\n  it('returns the input value even if it is considered falsy', function() {\n    eq('', defaultTo42(''));\n    eq(0, defaultTo42(0));\n    eq(false, defaultTo42(false));\n    eq([], defaultTo42([]));\n  });\n  it('can be called with both arguments directly', function() {\n    eq(42, R.defaultTo(42, null));\n    eq('a real value', R.defaultTo(42, 'a real value'));\n  });"},"difference":{"method":"difference","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('difference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('finds the set of all elements in the first list not contained in the second', function() {\n    eq(R.difference(M, N), [1, 2]);\n  });\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.difference(M2, N2), [1, 2]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.difference([0], [-0]).length, 1);\n    eq(R.difference([-0], [0]).length, 1);\n    eq(R.difference([NaN], [NaN]).length, 0);\n    eq(R.difference([new Just([42])], [new Just([42])]).length, 0);\n  });\n  it('works for arrays of different lengths', function() {\n    eq(R.difference(Z, Z2), [10]);\n    eq(R.difference(Z2, Z), [1, 2, 7, 8]);\n  });\n  it('will not create a \"sparse\" array', function() {\n    eq(R.difference(M2, [3]).length, 3);\n  });\n  it('returns an empty array if there are no different elements', function() {\n    eq(R.difference(M2, M), []);\n    eq(R.difference(M, M2), []);\n    eq(R.difference([], M2), []);\n  });"},"dissoc":{"method":"dissoc","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar assert = require('assert');\n\ndescribe('dissoc', function() {\n  it('copies an object omitting the specified property', function() {\n    eq(R.dissoc('b', {a: 1, b: 2, c: 3}), {a: 1, c: 3});\n    eq(R.dissoc('d', {a: 1, b: 2, c: 3}), {a: 1, b: 2, c: 3});\n    eq(R.dissoc('c', {a: 1, b: 2, c: null}), {a: 1, b: 2});\n    eq(R.dissoc('c', {a: 1, b: 2, c: undefined}), {a: 1, b: 2});\n    var obj1 = {a: 1, b: 2};\n    var obj2 = R.dissoc('c', obj1);\n    eq(obj2, obj1);\n    // Note: reference equality below!\n    assert.notStrictEqual(obj2, obj1);\n  });\n  it('makes a shallow clone of an array, remove only the specified index', function() {\n    var ary1 = [1, [2, 3], 4, 5];\n    var ary2 = R.dissoc(2, ary1);\n    var ary3 = R.dissoc(4, ary1);\n    eq(ary2, [1, [2, 3], 5]);\n    eq(ary3, [1, [2, 3], 4, 5]);\n    // Note: reference equality below!\n    assert.strictEqual(ary2[0], ary1[0]);\n    assert.strictEqual(ary2[1], ary1[1]);\n    assert.strictEqual(ary2[2], ary1[3]);\n    assert.notStrictEqual(ary3, ary1);\n    assert.strictEqual(ary3[0], ary1[0]);\n    assert.strictEqual(ary3[1], ary1[1]);\n    assert.strictEqual(ary3[2], ary1[2]);\n    assert.strictEqual(ary3[3], ary1[3]);\n  });\n  it('includes prototype properties', function() {\n    function Rectangle(width, height) {\n      this.width = width;\n      this.height = height;\n    }\n    var area = Rectangle.prototype.area = function() {\n      return this.width * this.height;\n    };\n    var rect = new Rectangle(7, 6);\n    eq(R.dissoc('area', rect), {width: 7, height: 6});\n    eq(R.dissoc('width', rect), {height: 6, area: area});\n    eq(R.dissoc('depth', rect), {width: 7, height: 6, area: area});\n  });\n  it('coerces non-string types', function() {\n    eq(R.dissoc(42, {a: 1, b: 2, 42: 3}), {a: 1, b: 2});\n    eq(R.dissoc(null, {a: 1, b: 2, 'null': 3}), {a: 1, b: 2});\n    eq(R.dissoc(undefined, {a: 1, b: 2, undefined: 3}), {a: 1, b: 2});\n  });"},"divide":{"method":"divide","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('divide', function() {\n  it('divides two numbers', function() {\n    eq(R.divide(28, 7), 4);\n  });"},"drop":{"method":"drop","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('drop', function() {\n  it('skips the first `n` elements from a list, returning the remainder', function() {\n    eq(R.drop(3, ['a', 'b', 'c', 'd', 'e', 'f', 'g']), ['d', 'e', 'f', 'g']);\n  });\n  it('returns an empty array if `n` is too large', function() {\n    eq(R.drop(20, ['a', 'b', 'c', 'd', 'e', 'f', 'g']), []);\n  });\n  it('returns an equivalent list if `n` is <= 0', function() {\n    eq(R.drop(0, [1, 2, 3]), [1, 2, 3]);\n    eq(R.drop(-1, [1, 2, 3]), [1, 2, 3]);\n    eq(R.drop(-Infinity, [1, 2, 3]), [1, 2, 3]);\n  });\n  it('never returns the input array', function() {\n    var xs = [1, 2, 3];\n    assert.notStrictEqual(R.drop(0, xs), xs);\n    assert.notStrictEqual(R.drop(-1, xs), xs);\n  });\n  it('can operate on strings', function() {\n    eq(R.drop(3, 'Ramda'), 'da');\n    eq(R.drop(4, 'Ramda'), 'a');\n    eq(R.drop(5, 'Ramda'), '');\n    eq(R.drop(6, 'Ramda'), '');\n  });"},"dropLast":{"diffReason":"Ramda method can act as a transducer","method":"dropLast","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('dropLast', function() {\n  it('skips the last `n` elements from a list, returning the remainder', function() {\n    eq(R.dropLast(3, ['a', 'b', 'c', 'd', 'e', 'f', 'g']), ['a', 'b', 'c', 'd']);\n  });\n  it('returns an empty array if `n` is too large', function() {\n    eq(R.dropLast(20, ['a', 'b', 'c', 'd', 'e', 'f', 'g']), []);\n  });\n  it('returns an equivalent list if `n` is <= 0', function() {\n    eq(R.dropLast(0, [1, 2, 3]), [1, 2, 3]);\n    eq(R.dropLast(-1, [1, 2, 3]), [1, 2, 3]);\n    eq(R.dropLast(-Infinity, [1, 2, 3]), [1, 2, 3]);\n  });\n  it('never returns the input array', function() {\n    var xs = [1, 2, 3];\n    assert.notStrictEqual(R.dropLast(0, xs), xs);\n    assert.notStrictEqual(R.dropLast(-1, xs), xs);\n  });\n  it('can operate on strings', function() {\n    eq(R.dropLast(3, 'Ramda'), 'Ra');\n  });\n  it('can act as a transducer', function() {\n    var dropLast2 = R.dropLast(2);\n    assert.deepEqual(R.into([], dropLast2, [1, 3, 5, 7, 9, 1, 2]), [1, 3, 5, 7, 9]);\n    assert.deepEqual(R.into([], dropLast2, [1]), []);\n  });"},"dropLastWhile":{"diffReason":"Ramda method can act as a transducer","method":"dropLastWhile","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('dropLastWhile', function() {\n  it('skips elements while the function reports `true`', function() {\n    eq(R.dropLastWhile(function(x) {return x >= 5;}, [1, 3, 5, 7, 9]), [1, 3]);\n  });\n  it('returns an empty list for an empty list', function() {\n    eq(R.dropLastWhile(function() { return false; }, []), []);\n    eq(R.dropLastWhile(function() { return true; }, []), []);\n  });\n  it('starts at the right arg and acknowledges undefined', function() {\n    var sublist = R.dropLastWhile(function(x) {return x !== void 0;}, [1, 3, void 0, 5, 7]);\n    eq(sublist.length, 3);\n    eq(sublist[0], 1);\n    eq(sublist[1], 3);\n    eq(sublist[2], void 0);\n  });\n  it('can operate on strings', function() {\n    eq(R.dropLastWhile(function(x) { return x !== 'd'; }, 'Ramda'), 'Ramd');\n  });\n  it('can act as a transducer', function() {\n    var dropLt7 = R.dropLastWhile(function(x) {return x < 7;});\n    eq(R.into([], dropLt7, [1, 3, 5, 7, 9, 1, 2]), [1, 3, 5, 7, 9]);\n    eq(R.into([], dropLt7, [1, 3, 5]), []);\n  });"},"dropRepeats":{"diffReason":"Ramda method can act as a transducer","method":"dropRepeats","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('dropRepeats', function() {\n  var objs = [1, 2, 3, 4, 5, 3, 2];\n  var objs2 = [1, 2, 2, 2, 3, 4, 4, 5, 5, 3, 2, 2];\n  it('removes repeated elements', function() {\n    eq(R.dropRepeats(objs2), objs);\n    eq(R.dropRepeats(objs), objs);\n  });\n  it('returns an empty array for an empty array', function() {\n    eq(R.dropRepeats([]), []);\n  });\n  it('can act as a transducer', function() {\n    eq(R.into([], R.dropRepeats, objs2), objs);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.dropRepeats([0, -0]).length, 2);\n    eq(R.dropRepeats([-0, 0]).length, 2);\n    eq(R.dropRepeats([NaN, NaN]).length, 1);\n    eq(R.dropRepeats([new Just([42]), new Just([42])]).length, 1);\n  });"},"dropRepeatsWith":{"method":"dropRepeatsWith","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('dropRepeatsWith', function() {\n  var objs = [\n    {i: 1}, {i: 2}, {i: 3}, {i: 4}, {i: 5}, {i: 3}\n  ];\n  var objs2 = [\n    {i: 1}, {i: 1}, {i: 1}, {i: 2}, {i: 3},\n    {i: 3}, {i: 4}, {i: 4}, {i: 5}, {i: 3}\n  ];\n  var eqI = R.eqProps('i');\n  it('removes repeated elements based on predicate', function() {\n    eq(R.dropRepeatsWith(eqI, objs2), objs);\n    eq(R.dropRepeatsWith(eqI, objs), objs);\n  });\n  it('keeps elements from the left', function() {\n    eq(\n      R.dropRepeatsWith(eqI, [{i: 1, n: 1}, {i: 1, n: 2}, {i: 1, n: 3}, {i: 4, n: 1}, {i: 4, n: 2}]),\n      [{i: 1, n: 1}, {i: 4, n: 1}]\n    );\n  });\n  it('returns an empty array for an empty array', function() {\n    eq(R.dropRepeatsWith(eqI, []), []);\n  });\n  it('can act as a transducer', function() {\n    eq(R.into([], R.dropRepeatsWith(eqI), objs2), objs);\n  });"},"dropWhile":{"method":"dropWhile","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('dropWhile', function() {\n  it('skips elements while the function reports `true`', function() {\n    eq(R.dropWhile(function(x) {return x < 5;}, [1, 3, 5, 7, 9]), [5, 7, 9]);\n  });\n  it('returns an empty list for an empty list', function() {\n    eq(R.dropWhile(function() { return false; }, []), []);\n    eq(R.dropWhile(function() { return true; }, []), []);\n  });\n  it('starts at the right arg and acknowledges undefined', function() {\n    var sublist = R.dropWhile(function(x) {return x !== void 0;}, [1, 3, void 0, 5, 7]);\n    eq(sublist.length, 3);\n    eq(sublist[0], void 0);\n    eq(sublist[1], 5);\n    eq(sublist[2], 7);\n  });\n  it('can operate on strings', function() {\n    eq(R.dropWhile(function(x) { return x !== 'd'; }, 'Ramda'), 'da');\n  });"},"either":{"diffReason":"Ramda library supports fantasy-land","method":"either","content":"var S = require('sanctuary');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('either', function() {\n  it('combines two boolean-returning functions into one', function() {\n    var even = function(x) {return x % 2 === 0;};\n    var gt10 = function(x) {return x > 10;};\n    var f = R.either(even, gt10);\n    eq(f(8), true);\n    eq(f(13), true);\n    eq(f(7), false);\n  });\n  it('accepts functions that take multiple parameters', function() {\n    var between = function(a, b, c) {return a < b && b < c;};\n    var total20 = function(a, b, c) {return a + b + c === 20;};\n    var f = R.either(between, total20);\n    eq(f(4, 5, 8), true);\n    eq(f(12, 2, 6), true);\n    eq(f(7, 5, 1), false);\n  });\n  it('does not evaluate the second expression if the first one is true', function() {\n    var T = function() { return true; };\n    var Z = function() { effect = 'Z got evaluated'; };\n    var effect = 'not evaluated';\n    R.either(T, Z)();\n    eq(effect, 'not evaluated');\n  });\n  it('accepts fantasy-land applicative functors', function() {\n    var Just = S.Just;\n    var Nothing = S.Nothing;\n    eq(R.either(Just(true), Just(true)), Just(true));\n    eq(R.either(Just(true), Just(false)), Just(true));\n    eq(R.either(Just(false), Just(false)), Just(false));\n    eq(R.either(Just(true), Nothing()), Nothing());\n    eq(R.either(Nothing(), Just(false)), Nothing());\n    eq(R.either(Nothing(), Nothing()), Nothing());\n  });"},"endsWith":{"method":"endsWith","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('endsWith', function() {\n  it('should return true when a string ends with the provided value', function() {\n    eq(R.endsWith('c', 'abc'), true);\n  });\n  it('should return true when a long string ends with the provided value', function() {\n    eq(R.endsWith('ology', 'astrology'), true);\n  });\n  it('should return false when a string does not end with the provided value', function() {\n    eq(R.endsWith('b', 'abc'), false);\n  });\n  it('should return false when a long string does not end with the provided value', function() {\n    eq(R.endsWith('olog', 'astrology'), false);\n  });\n  it('should return true when an array ends with the provided value', function() {\n    eq(R.endsWith(['c'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array ends with the provided values', function() {\n    eq(R.endsWith(['b', 'c'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not end with the provided value', function() {\n    eq(R.endsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not end with the provided values', function() {\n    eq(R.endsWith(['a', 'b'], ['a', 'b', 'c']), false);\n  });"},"eqProps":{"method":"eqProps","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('eqProps', function() {\n  it('reports whether two objects have the same value for a given property', function() {\n    eq(R.eqProps('name', {name: 'fred', age: 10}, {name: 'fred', age: 12}), true);\n    eq(R.eqProps('name', {name: 'fred', age: 10}, {name: 'franny', age: 10}), false);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.eqProps('value', {value: 0}, {value: -0}), false);\n    eq(R.eqProps('value', {value: -0}, {value: 0}), false);\n    eq(R.eqProps('value', {value: NaN}, {value: NaN}), true);\n    eq(R.eqProps('value', {value: new Just([42])}, {value: new Just([42])}), true);\n  });"},"equals":{"diffReason":"Rambda method doesn't support recursive data structures, objects with same enumerable properties, map/weakmap type of variables | Ramda dispatches to `equals` method recursively | Rambda method doesn't support equality of functions","method":"equals","content":"/* global Map, Set, WeakMap, WeakSet */\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\ndescribe('equals', function() {\n  var a = [];\n  var b = a;\n  it('tests for deep equality of its operands', function() {\n    eq(R.equals(100, 100), true);\n    eq(R.equals(100, '100'), false);\n    eq(R.equals([], []), true);\n    eq(R.equals(a, b), true);\n  });\n  it('considers equal Boolean primitives equal', function() {\n    eq(R.equals(true, true), true);\n    eq(R.equals(false, false), true);\n    eq(R.equals(true, false), false);\n    eq(R.equals(false, true), false);\n  });\n  it('considers equivalent Boolean objects equal', function() {\n    eq(R.equals(new Boolean(true), new Boolean(true)), true);\n    eq(R.equals(new Boolean(false), new Boolean(false)), true);\n    eq(R.equals(new Boolean(true), new Boolean(false)), false);\n    eq(R.equals(new Boolean(false), new Boolean(true)), false);\n  });\n  it('never considers Boolean primitive equal to Boolean object', function() {\n    eq(R.equals(true, new Boolean(true)), false);\n    eq(R.equals(new Boolean(true), true), false);\n    eq(R.equals(false, new Boolean(false)), false);\n    eq(R.equals(new Boolean(false), false), false);\n  });\n  it('considers equal number primitives equal', function() {\n    eq(R.equals(0, 0), true);\n    eq(R.equals(0, 1), false);\n    eq(R.equals(1, 0), false);\n  });\n  it('considers equivalent Number objects equal', function() {\n    eq(R.equals(new Number(0), new Number(0)), true);\n    eq(R.equals(new Number(0), new Number(1)), false);\n    eq(R.equals(new Number(1), new Number(0)), false);\n  });\n  it('never considers number primitive equal to Number object', function() {\n    eq(R.equals(0, new Number(0)), false);\n    eq(R.equals(new Number(0), 0), false);\n  });\n  it('considers equal string primitives equal', function() {\n    eq(R.equals('', ''), true);\n    eq(R.equals('', 'x'), false);\n    eq(R.equals('x', ''), false);\n    eq(R.equals('foo', 'foo'), true);\n    eq(R.equals('foo', 'bar'), false);\n    eq(R.equals('bar', 'foo'), false);\n  });\n  it('considers equivalent String objects equal', function() {\n    eq(R.equals(new String(''), new String('')), true);\n    eq(R.equals(new String(''), new String('x')), false);\n    eq(R.equals(new String('x'), new String('')), false);\n    eq(R.equals(new String('foo'), new String('foo')), true);\n    eq(R.equals(new String('foo'), new String('bar')), false);\n    eq(R.equals(new String('bar'), new String('foo')), false);\n  });\n  it('never considers string primitive equal to String object', function() {\n    eq(R.equals('', new String('')), false);\n    eq(R.equals(new String(''), ''), false);\n    eq(R.equals('x', new String('x')), false);\n    eq(R.equals(new String('x'), 'x'), false);\n  });\n  it('handles objects', function() {\n    eq(R.equals({}, {}), true);\n    eq(R.equals({a:1, b:2}, {a:1, b:2}), true);\n    eq(R.equals({a:2, b:3}, {b:3, a:2}), true);\n    eq(R.equals({a:2, b:3}, {a:3, b:3}), false);\n    eq(R.equals({a:2, b:3, c:1}, {a:2, b:3}), false);\n  });\n  it('considers equivalent Arguments objects equal', function() {\n    var a = (function() { return arguments; }());\n    var b = (function() { return arguments; }());\n    var c = (function() { return arguments; }(1, 2, 3));\n    var d = (function() { return arguments; }(1, 2, 3));\n    eq(R.equals(a, b), true);\n    eq(R.equals(b, a), true);\n    eq(R.equals(c, d), true);\n    eq(R.equals(d, c), true);\n    eq(R.equals(a, c), false);\n    eq(R.equals(c, a), false);\n  });\n  it('considers equivalent Error objects equal', function() {\n    eq(R.equals(new Error('XXX'), new Error('XXX')), true);\n    eq(R.equals(new Error('XXX'), new Error('YYY')), false);\n    eq(R.equals(new Error('XXX'), new TypeError('XXX')), false);\n    eq(R.equals(new Error('XXX'), new TypeError('YYY')), false);\n  });\n  var supportsSticky = false;\n  try { RegExp('', 'y'); supportsSticky = true; } catch (e) {}\n  var supportsUnicode = false;\n  try { RegExp('', 'u'); supportsUnicode = true; } catch (e) {}\n  it('handles regex', function() {\n    eq(R.equals(/\\s/, /\\s/), true);\n    eq(R.equals(/\\s/, /\\d/), false);\n    eq(R.equals(/a/gi, /a/ig), true);\n    eq(R.equals(/a/mgi, /a/img), true);\n    eq(R.equals(/a/gi, /a/i), false);\n    if (supportsSticky) {\n      // eq(R.equals(/\\s/y, /\\s/y), true);\n      // eq(R.equals(/a/mygi, /a/imgy), true);\n    }\n    if (supportsUnicode) {\n      // eq(R.equals(/\\s/u, /\\s/u), true);\n      // eq(R.equals(/a/mugi, /a/imgu), true);\n    }\n  });\n  var listA = [1, 2, 3];\n  var listB = [1, 3, 2];\n  it('handles lists', function() {\n    eq(R.equals([], {}), false);\n    eq(R.equals(listA, listB), false);\n  });\n  var c = {}; c.v = c;\n  var d = {}; d.v = d;\n  var e = []; e.push(e);\n  var f = []; f.push(f);\n  var nestA = {a:[1, 2, {c:1}], b:1};\n  var nestB = {a:[1, 2, {c:1}], b:1};\n  var nestC = {a:[1, 2, {c:2}], b:1};\n  it('handles recursive data structures', function() {\n    eq(R.equals(c, d), true);\n    eq(R.equals(e, f), true);\n    eq(R.equals(nestA, nestB), true);\n    eq(R.equals(nestA, nestC), false);\n  });\n  it('handles dates', function() {\n    eq(R.equals(new Date(0), new Date(0)), true);\n    eq(R.equals(new Date(1), new Date(1)), true);\n    eq(R.equals(new Date(0), new Date(1)), false);\n    eq(R.equals(new Date(1), new Date(0)), false);\n  });\n  it('requires that both objects have the same enumerable properties with the same values', function() {\n    var a1 = [];\n    var a2 = [];\n    a2.x = 0;\n    var b1 = new Boolean(false);\n    var b2 = new Boolean(false);\n    b2.x = 0;\n    var d1 = new Date(0);\n    var d2 = new Date(0);\n    d2.x = 0;\n    var n1 = new Number(0);\n    var n2 = new Number(0);\n    n2.x = 0;\n    var r1 = /(?:)/;\n    var r2 = /(?:)/;\n    r2.x = 0;\n    var s1 = new String('');\n    var s2 = new String('');\n    s2.x = 0;\n    eq(R.equals(a1, a2), false);\n    eq(R.equals(b1, b2), false);\n    eq(R.equals(d1, d2), false);\n    eq(R.equals(n1, n2), false);\n    eq(R.equals(r1, r2), false);\n    eq(R.equals(s1, s2), false);\n  });\n  if (typeof ArrayBuffer !== 'undefined' && typeof Int8Array !== 'undefined') {\n    var typArr1 = new ArrayBuffer(10);\n    typArr1[0] = 1;\n    var typArr2 = new ArrayBuffer(10);\n    typArr2[0] = 1;\n    var typArr3 = new ArrayBuffer(10);\n    var intTypArr = new Int8Array(typArr1);\n    typArr3[0] = 0;\n    it('handles typed arrays', function() {\n      eq(R.equals(typArr1, typArr2), true);\n      eq(R.equals(typArr1, typArr3), false);\n      eq(R.equals(typArr1, intTypArr), false);\n    });\n  }\n  if (typeof Promise !== 'undefined') {\n    it('compares Promise objects by identity', function() {\n      var p = Promise.resolve(42);\n      var q = Promise.resolve(42);\n      eq(R.equals(p, p), true);\n      eq(R.equals(p, q), false);\n  }\n  if (typeof Map !== 'undefined') {\n    it('compares Map objects by value', function() {\n      eq(R.equals(new Map([]), new Map([])), true);\n      eq(R.equals(new Map([]), new Map([[1, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, 'b']]), new Map([[2, 'b'], [1, 'a']])), true);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[2, 'a']])), false);\n      eq(R.equals(new Map([[1, 'a']]), new Map([[1, 'b']])), false);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'c']])]])), true);\n      eq(R.equals(new Map([[1, 'a'], [2, new Map([[3, 'c']])]]), new Map([[1, 'a'], [2, new Map([[3, 'd']])]])), false);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [4, 5, 6]]])), true);\n      eq(R.equals(new Map([[[1, 2, 3], [4, 5, 6]]]), new Map([[[1, 2, 3], [7, 8, 9]]])), false);\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Map();\n      var b = new Map();\n      a.set(a, a);\n      eq(R.equals(a, b), false);\n      a.set(b, b);\n      b.set(b, b);\n      b.set(a, a);\n      eq(R.equals(a, b), true);\n  }\n  if (typeof Set !== 'undefined') {\n    it('compares Set objects by value', function() {\n      eq(R.equals(new Set([]), new Set([])), true);\n      eq(R.equals(new Set([]), new Set([1])), false);\n      eq(R.equals(new Set([1]), new Set([])), false);\n      eq(R.equals(new Set([1, 2]), new Set([2, 1])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([3])])])), true);\n      eq(R.equals(new Set([1, new Set([2, new Set([3])])]), new Set([1, new Set([2, new Set([4])])])), false);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [4, 5, 6]])), true);\n      eq(R.equals(new Set([[1, 2, 3], [4, 5, 6]]), new Set([[1, 2, 3], [7, 8, 9]])), false);\n    it('dispatches to `equals` method recursively in Set', function() {\n      var a = new Set();\n      var b = new Set();\n      a.add(a);\n      eq(R.equals(a, b), false);\n      a.add(b);\n      b.add(b);\n      b.add(a);\n      eq(R.equals(a, b), true);\n  }\n  if (typeof WeakMap !== 'undefined') {\n    it('compares WeakMap objects by identity', function() {\n      var m = new WeakMap([]);\n      eq(R.equals(m, m), true);\n      eq(R.equals(m, new WeakMap([])), false);\n  }\n  if (typeof WeakSet !== 'undefined') {\n    it('compares WeakSet objects by identity', function() {\n      var s = new WeakSet([]);\n      eq(R.equals(s, s), true);\n      eq(R.equals(s, new WeakSet([])), false);\n  }\n  it('dispatches to `equals` method recursively', function() {\n    function Left(x) { this.value = x; }\n    Left.prototype.equals = function(x) {\n      return x instanceof Left && R.equals(x.value, this.value);\n    };\n    function Right(x) { this.value = x; }\n    Right.prototype.equals = function(x) {\n      return x instanceof Right && R.equals(x.value, this.value);\n    };\n    eq(R.equals(new Left([42]), new Left([42])), true);\n    eq(R.equals(new Left([42]), new Left([43])), false);\n    eq(R.equals(new Left(42), {value: 42}), false);\n    eq(R.equals({value: 42}, new Left(42)), false);\n    eq(R.equals(new Left(42), new Right(42)), false);\n    eq(R.equals(new Right(42), new Left(42)), false);\n    eq(R.equals([new Left(42)], [new Left(42)]), true);\n    eq(R.equals([new Left(42)], [new Right(42)]), false);\n    eq(R.equals([new Right(42)], [new Left(42)]), false);\n    eq(R.equals([new Right(42)], [new Right(42)]), true);\n  });\n  it('is commutative', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    Point.prototype.equals = function(point) {\n      return point instanceof Point &&\n             this.x === point.x && this.y === point.y;\n    };\n    function ColorPoint(x, y, color) {\n      this.x = x;\n      this.y = y;\n      this.color = color;\n    }\n    ColorPoint.prototype = new Point(0, 0);\n    ColorPoint.prototype.equals = function(point) {\n      return point instanceof ColorPoint &&\n             this.x === point.x && this.y === point.y &&\n             this.color === point.color;\n    };\n    eq(R.equals(new Point(2, 2), new ColorPoint(2, 2, 'red')), false);\n    eq(R.equals(new ColorPoint(2, 2, 'red'), new Point(2, 2)), false);\n  });\n  // Arbitrary configured to produce any kind of values\n  // from simple numbers to complex objects\n  const anythingInstanceArb = fc.anything({\n    withBoxedValues: true, // eg.: new Number(1), ...\n    withNullPrototype: true, // eg.: Object.create(null), ...\n    withObjectString: true, // eg.: \"{}\", \"null\", ...\n    withMap: typeof Map !== 'undefined',\n    withSet: typeof Set !== 'undefined'\n  });\n  it('perfect clones should be considered equal', function() {\n    fc.assert(fc.property(fc.clone(anythingInstanceArb, 2), function(values) {\n      eq(R.equals(values[0], values[1]), true);\n    }));\n  });\n  it('is commutative whatever the values', function() {\n    fc.assert(fc.property(anythingInstanceArb, anythingInstanceArb, function(v1, v2) {\n      eq(R.equals(v1, v2), R.equals(v2, v1));\n    }));\n  });\n});"},"evolve":{"diffReason":"Rambda throws if `iterable` input is neither array nor object","method":"evolve","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('evolve', function() {\n  it('creates a new object by evolving the `object` according to the `transformation` functions', function() {\n    var transf   = {elapsed: R.add(1), remaining: R.add(-1)};\n    var object   = {name: 'Tomato', elapsed: 100, remaining: 1400};\n    var expected = {name: 'Tomato', elapsed: 101, remaining: 1399};\n    eq(R.evolve(transf, object), expected);\n  });\n  it('does not invoke function if object does not contain the key', function() {\n    var transf   = {n: R.add(1), m: R.add(1)};\n    var object   = {m: 3};\n    var expected = {m: 4};\n    eq(R.evolve(transf, object), expected);\n  });\n  it('is not destructive', function() {\n    var transf   = {elapsed: R.add(1), remaining: R.add(-1)};\n    var object   = {name: 'Tomato', elapsed: 100, remaining: 1400};\n    var expected = {name: 'Tomato', elapsed: 100, remaining: 1400};\n    R.evolve(transf, object);\n    eq(object, expected);\n  });\n  it('is recursive', function() {\n    var transf   = {nested: {second: R.add(-1), third: R.add(1)}};\n    var object   = {first: 1, nested: {second: 2, third: 3}};\n    var expected = {first: 1, nested: {second: 1, third: 4}};\n    eq(R.evolve(transf, object), expected);\n  });\n  it('ignores primitive value transformations', function() {\n    var transf   = {n: 2, m: 'foo'};\n    var object   = {n: 0, m: 1};\n    var expected = {n: 0, m: 1};\n    eq(R.evolve(transf, object), expected);\n  });\n  it('ignores null transformations', function() {\n    var transf   = {n: null};\n    var object   = {n: 0};\n    var expected = {n: 0};\n    eq(R.evolve(transf, object), expected);\n  });\n  it('creates a new array by evolving the `array` according to the `transformation` functions', function() {\n    var transf   = [R.add(1), R.add(-1)];\n    var object   = [100, 1400];\n    var expected = [101, 1399];\n    eq(R.evolve(transf, object), expected);\n  });\n  it('ignores transformations if the input value is not Array and Object', function() {\n    var transf   = { a: R.add(1) };\n    eq(R.evolve(transf, 42), 42);\n    eq(R.evolve(transf, undefined), undefined);\n    eq(R.evolve(transf, null), null);\n    eq(R.evolve(transf, ''), '');\n  });"},"filter":{"diffReason":"Ramda method dispatches to `filter` method of object","method":"filter","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar Maybe = require('./shared/Maybe');\n\ndescribe('filter', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('reduces an array to those matching a filter', function() {\n    eq(R.filter(even, [1, 2, 3, 4, 5]), [2, 4]);\n  });\n  it('returns an empty array if no element matches', function() {\n    eq(R.filter(function(x) { return x > 100; }, [1, 9, 99]), []);\n  });\n  it('returns an empty array if asked to filter an empty array', function() {\n    eq(R.filter(function(x) { return x > 100; }, []), []);\n  });\n  it('filters objects', function() {\n    var positive = function(x) { return x > 0; };\n    eq(R.filter(positive, {}), {});\n    eq(R.filter(positive, {x: 0, y: 0, z: 0}), {});\n    eq(R.filter(positive, {x: 1, y: 0, z: 0}), {x: 1});\n    eq(R.filter(positive, {x: 1, y: 2, z: 0}), {x: 1, y: 2});\n    eq(R.filter(positive, {x: 1, y: 2, z: 3}), {x: 1, y: 2, z: 3});\n  });\n  it('dispatches to passed-in non-Array object with a `filter` method', function() {\n    var f = {filter: function(f) { return f('called f.filter'); }};\n    eq(R.filter(function(s) { return s; }, f), 'called f.filter');\n  });\n  it('correctly uses fantasy-land implementations', function() {\n    var m1 = Maybe.Just(-1);\n    var m2 = R.filter(function(x) { return x > 0; } , m1);\n    eq(m2.isNothing, true);\n  });"},"find":{"method":"find","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\n\ndescribe('find', function() {\n  var obj1 = {x: 100};\n  var obj2 = {x: 200};\n  var a = [11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0];\n  var even = function(x) { return x % 2 === 0; };\n  var gt100 = function(x) { return x > 100; };\n  var isStr = function(x) { return typeof x === 'string'; };\n  var xGt100 = function(o) { return o && o.x > 100; };\n  var intoArray = R.into([]);\n  it('returns the first element that satisfies the predicate', function() {\n    eq(R.find(even, a), 10);\n    eq(R.find(gt100, a), 200);\n    eq(R.find(isStr, a), 'cow');\n    eq(R.find(xGt100, a), obj2);\n  });\n  it('transduces the first element that satisfies the predicate into an array', function() {\n    eq(intoArray(R.find(even), a), [10]);\n    eq(intoArray(R.find(gt100), a), [200]);\n    eq(intoArray(R.find(isStr), a), ['cow']);\n    eq(intoArray(R.find(xGt100), a), [obj2]);\n  });\n  it('returns `undefined` when no element satisfies the predicate', function() {\n    eq(R.find(even, ['zing']), undefined);\n  });\n  it('returns `undefined` in array when no element satisfies the predicate into an array', function() {\n    eq(intoArray(R.find(even), ['zing']), [undefined]);\n  });\n  it('returns `undefined` when given an empty list', function() {\n    eq(R.find(even, []), undefined);\n  });\n  it('returns `undefined` into an array when given an empty list', function() {\n    eq(intoArray(R.find(even), []), [undefined]);\n  });\n  it('dispatches to transformer objects', function() {\n    eq(R.find(R.identity, listXf), {\n      f: R.identity,\n      found: false,\n      xf: listXf\n    });\n  });"},"findIndex":{"method":"findIndex","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\n\ndescribe('findIndex', function() {\n  var obj1 = {x: 100};\n  var obj2 = {x: 200};\n  var a = [11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0];\n  var even = function(x) { return x % 2 === 0; };\n  var gt100 = function(x) { return x > 100; };\n  var isStr = function(x) { return typeof x === 'string'; };\n  var xGt100 = function(o) { return o && o.x > 100; };\n  var intoArray = R.into([]);\n  it('returns the index of the first element that satisfies the predicate', function() {\n    eq(R.findIndex(even, a), 1);\n    eq(R.findIndex(gt100, a), 8);\n    eq(R.findIndex(isStr, a), 3);\n    eq(R.findIndex(xGt100, a), 10);\n  });\n  it('returns the index of the first element that satisfies the predicate into an array', function() {\n    eq(intoArray(R.findIndex(even), a), [1]);\n    eq(intoArray(R.findIndex(gt100), a), [8]);\n    eq(intoArray(R.findIndex(isStr), a), [3]);\n    eq(intoArray(R.findIndex(xGt100), a), [10]);\n  });\n  it('returns -1 when no element satisfies the predicate', function() {\n    eq(R.findIndex(even, ['zing']), -1);\n    eq(R.findIndex(even, []), -1);\n  });\n  it('returns -1 in array when no element satisfies the predicate into an array', function() {\n    eq(intoArray(R.findIndex(even), ['zing']), [-1]);\n  });\n  it('dispatches to transformer objects', function() {\n    eq(R.findIndex(R.identity, listXf), {\n      f: R.identity,\n      found: false,\n      idx: -1,\n      xf: listXf\n    });\n  });"},"findLast":{"method":"findLast","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\n\ndescribe('findLast', function() {\n  var obj1 = {x: 100};\n  var obj2 = {x: 200};\n  var a = [11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0];\n  var even = function(x) { return x % 2 === 0; };\n  var gt100 = function(x) { return x > 100; };\n  var isStr = function(x) { return typeof x === 'string'; };\n  var xGt100 = function(o) { return o && o.x > 100; };\n  var intoArray = R.into([]);\n  it('returns the index of the last element that satisfies the predicate', function() {\n    eq(R.findLast(even, a), 0);\n    eq(R.findLast(gt100, a), 300);\n    eq(R.findLast(isStr, a), 'cow');\n    eq(R.findLast(xGt100, a), obj2);\n  });\n  it('returns the index of the last element that satisfies the predicate into an array', function() {\n    eq(intoArray(R.findLast(even), a), [0]);\n    eq(intoArray(R.findLast(gt100), a), [300]);\n    eq(intoArray(R.findLast(isStr), a), ['cow']);\n    eq(intoArray(R.findLast(xGt100), a), [obj2]);\n  });\n  it('returns `undefined` when no element satisfies the predicate', function() {\n    eq(R.findLast(even, ['zing']), undefined);\n  });\n  it('returns `undefined` into an array when no element satisfies the predicate', function() {\n    eq(intoArray(R.findLast(even), ['zing']), [undefined]);\n  });\n  it('works when the first element matches', function() {\n    eq(R.findLast(even, [2, 3, 5]), 2);\n  });\n  it('does not go into an infinite loop on an empty array', function() {\n    eq(R.findLast(even, []), undefined);\n  });\n  it('dispatches to transformer objects', function() {\n    eq(R.findLast(R.identity, listXf), {\n      f: R.identity,\n      xf: listXf\n    });\n  });"},"findLastIndex":{"method":"findLastIndex","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\n\ndescribe('findLastIndex', function() {\n  var obj1 = {x: 100};\n  var obj2 = {x: 200};\n  var a = [11, 10, 9, 'cow', obj1, 8, 7, 100, 200, 300, obj2, 4, 3, 2, 1, 0];\n  var even = function(x) { return x % 2 === 0; };\n  var gt100 = function(x) { return x > 100; };\n  var isStr = function(x) { return typeof x === 'string'; };\n  var xGt100 = function(o) { return o && o.x > 100; };\n  var intoArray = R.into([]);\n  it('returns the index of the last element that satisfies the predicate', function() {\n    eq(R.findLastIndex(even, a), 15);\n    eq(R.findLastIndex(gt100, a), 9);\n    eq(R.findLastIndex(isStr, a), 3);\n    eq(R.findLastIndex(xGt100, a), 10);\n  });\n  it('returns -1 when no element satisfies the predicate', function() {\n    eq(R.findLastIndex(even, ['zing']), -1);\n  });\n  it('returns the index of the last element into an array that satisfies the predicate', function() {\n    eq(intoArray(R.findLastIndex(even), a), [15]);\n    eq(intoArray(R.findLastIndex(gt100), a), [9]);\n    eq(intoArray(R.findLastIndex(isStr), a), [3]);\n    eq(intoArray(R.findLastIndex(xGt100), a), [10]);\n  });\n  it('returns -1 into an array when no element satisfies the predicate', function() {\n    eq(intoArray(R.findLastIndex(even), ['zing']), [-1]);\n  });\n  it('works when the first element matches', function() {\n    eq(R.findLastIndex(even, [2, 3, 5]), 0);\n  });\n  it('does not go into an infinite loop on an empty array', function() {\n    eq(R.findLastIndex(even, []), -1);\n  });\n  it('dispatches to transformer objects', function() {\n    eq(R.findLastIndex(R.identity, listXf), {\n      f: R.identity,\n      idx: -1,\n      lastIdx: -1,\n      xf: listXf\n    });\n  });"},"flatten":{"method":"flatten","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('flatten', function() {\n  it('turns a nested list into one flat list', function() {\n    var nest = [1, [2], [3, [4, 5], 6, [[[7], 8]]], 9, 10];\n    eq(R.flatten(nest), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n    nest = [[[[3]], 2, 1], 0, [[-1, -2], -3]];\n    eq(R.flatten(nest), [3, 2, 1, 0, -1, -2, -3]);\n    eq(R.flatten([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n  });\n  it('is not destructive', function() {\n    var nest = [1, [2], [3, [4, 5], 6, [[[7], 8]]], 9, 10];\n    assert.notStrictEqual(R.flatten(nest), nest);\n  });\n  it('handles ridiculously large inputs', function() {\n    this.timeout(10000);\n    eq(R.flatten([new Array(1000000), R.range(0, 56000), 5, 1, 3]).length, 1056003);\n  });\n  it('handles array-like objects', function() {\n    var o = {length: 3, 0: [1, 2, [3]], 1: [], 2: ['a', 'b', 'c', ['d', 'e']]};\n    eq(R.flatten(o), [1, 2, 3, 'a', 'b', 'c', 'd', 'e']);\n  });\n  it('flattens an array of empty arrays', function() {\n    eq(R.flatten([[], [], []]), []);\n    eq(R.flatten([]), []);\n  });"},"flip":{"diffReason":"Ramda.flip returns a curried function | Rambda.flip work only for functions with arity below 5","method":"flip","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\n\ndescribe('flip', function() {\n  it('returns a function which inverts the first two arguments to the supplied function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f);\n    eq(f('a', 'b', 'c'), 'a b c');\n    eq(g('a', 'b', 'c'), 'b a c');\n  });\n  it('returns a curried function', function() {\n    var f = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    var g = R.flip(f)('a');\n    eq(g('b', 'c'), 'b a c');\n  });\n  it('returns a function with the correct arity', function() {\n    var f2 = function(a, b) {return a + ' ' + b;};\n    var f3 = function(a, b, c) {return a + ' ' + b + ' ' + c;};\n    eq(R.flip(f2).length, 2);\n    eq(R.flip(f3).length, 3);\n  });\ndescribe('flip properties', function() {\n  it('inverts first two arguments', function() {\n    fc.assert(fc.property(fc.func(fc.anything()), fc.anything(), fc.anything(), fc.anything(), function(f, a, b, c) {\n      var g = R.flip(f);\n      return R.equals(f(a, b, c), g(b, a, c));\n    }));\n  });"},"forEach":{"diffReason":"Ramda method dispatches to `forEach` method","method":"forEach","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('forEach', function() {\n  var list = [{x: 1, y: 2}, {x: 100, y: 200}, {x: 300, y: 400}, {x: 234, y: 345}];\n  it('performs the passed in function on each element of the list', function() {\n    var sideEffect = {};\n    R.forEach(function(elem) { sideEffect[elem.x] = elem.y; }, list);\n    eq(sideEffect, {1: 2, 100: 200, 300: 400, 234: 345});\n  });\n  it('returns the original list', function() {\n    var s = '';\n    eq(R.forEach(function(obj) { s += obj.x; }, list), list);\n    eq('1100300234', s);\n  });\n  it('handles empty list', function() {\n    eq(R.forEach(function(x) { return x * x; }, []), []);\n  });\n  it('dispatches to `forEach` method', function() {\n    var dispatched = false;\n    var fn = function() {};\n    function DummyList() {}\n    DummyList.prototype.forEach = function(callback) {\n      dispatched = true;\n      eq(callback, fn);\n    };\n    R.forEach(fn, new DummyList());\n    eq(dispatched, true);\n  });"},"fromPairs":{"method":"fromPairs","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('fromPairs', function() {\n  it('combines an array of two-element arrays into an object', function() {\n    eq(R.fromPairs([['a', 1], ['b', 2], ['c', 3]]), {a: 1, b: 2, c: 3});\n  });\n  it('gives later entries precedence over earlier ones', function() {\n    eq(R.fromPairs([['x', 1], ['x', 2]]), {x: 2});\n  });"},"groupBy":{"diffReason":"Ramda method support transforms","method":"groupBy","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar _isTransformer = require('rambda/internal/_isTransformer');\n\ndescribe('groupBy', function() {\n  it('splits the list into groups according to the grouping function', function() {\n    var grade = function(score) {\n      return (score < 65) ? 'F' : (score < 70) ? 'D' : (score < 80) ? 'C' : (score < 90) ? 'B' : 'A';\n    };\n    var students = [\n      {name: 'Abby', score: 84},\n      {name: 'Brad', score: 73},\n      {name: 'Chris', score: 89},\n      {name: 'Dianne', score: 99},\n      {name: 'Eddy', score: 58},\n      {name: 'Fred', score: 67},\n      {name: 'Gillian', score: 91},\n      {name: 'Hannah', score: 78},\n      {name: 'Irene', score: 85},\n      {name: 'Jack', score: 69}\n    ];\n    var byGrade = function(student) {return grade(student.score || 0);};\n    eq(R.groupBy(byGrade, students), {\n      A: [{name: 'Dianne', score: 99}, {name: 'Gillian', score: 91}],\n      B: [{name: 'Abby', score: 84}, {name: 'Chris', score: 89}, {name: 'Irene', score: 85}],\n      C: [{name: 'Brad', score: 73}, {name: 'Hannah', score: 78}],\n      D: [{name: 'Fred', score: 67}, {name: 'Jack', score: 69}],\n      F: [{name: 'Eddy', score: 58}]\n    });\n  });\n  it('returns an empty object if given an empty array', function() {\n    eq(R.groupBy(R.prop('x'), []), {});\n  });\n  it('dispatches on transformer objects in list position', function() {\n    var byType = R.prop('type');\n    var xf = {\n      '@@transducer/init': function() { return {}; },\n      '@@transducer/result': function(x) { return x; },\n      '@@transducer/step': R.mergeRight\n    };\n    eq(_isTransformer(R.groupBy(byType, xf)), true);\n  });"},"groupWith":{"diffReason":"Ramda method support string","method":"groupWith","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('groupWith', function() {\n  it('splits the list into groups according to the grouping function', function() {\n    eq(R.groupWith(R.equals, [1, 2, 2, 3]), [[1], [2, 2], [3]]);\n    eq(R.groupWith(R.equals, [1, 1, 1, 1]), [[1, 1, 1, 1]]);\n    eq(R.groupWith(R.equals, [1, 2, 3, 4]), [[1], [2], [3], [4]]);\n  });\n  it('splits the list into \"streaks\" testing adjacent elements', function() {\n    var isConsecutive = function(a, b) { return a + 1 === b; };\n    eq(R.groupWith(isConsecutive, []), []);\n    eq(R.groupWith(isConsecutive, [4, 3, 2, 1]), [[4], [3], [2], [1]]);\n    eq(R.groupWith(isConsecutive, [1, 2, 3, 4]), [[1, 2, 3, 4]]);\n    eq(R.groupWith(isConsecutive, [1, 2, 2, 3]), [[1, 2], [2, 3]]);\n    eq(R.groupWith(isConsecutive, [1, 2, 9, 3, 4]), [[1, 2], [9], [3, 4]]);\n  });\n  it('returns an empty array if given an empty array', function() {\n    eq(R.groupWith(R.equals, []), []);\n  });\n  it('can be turned into the original list through concatenation', function() {\n    var list = [1, 1, 2, 3, 4, 4, 5, 5];\n    eq(R.unnest(R.groupWith(R.equals, list)), list);\n    eq(R.unnest(R.groupWith(R.complement(R.equals), list)), list);\n    eq(R.unnest(R.groupWith(R.T, list)), list);\n    eq(R.unnest(R.groupWith(R.F, list)), list);\n  });\n  it('also works on strings', function() {\n    eq(R.groupWith(R.equals)('Mississippi'), ['M','i','ss','i','ss','i','pp','i']);\n  });"},"has":{"diffReason":"Rambda method does check properties from the prototype chain","method":"has","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('has', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  it('returns true if the specified property is present', function() {\n    eq(R.has('name', fred), true);\n  });\n  it('returns false if the specified property is absent', function() {\n    eq(R.has('name', anon), false);\n  });\n  it('does not check properties from the prototype chain', function() {\n    var Person = function() {};\n    Person.prototype.age = function() {};\n    var bob = new Person();\n    eq(R.has('age', bob), false);\n  });\n  it('returns false for non-objects', function() {\n    eq(R.has('a', undefined), false);\n    eq(R.has('a', null), false);\n    eq(R.has('a', true), false);\n    eq(R.has('a', ''), false);\n    eq(R.has('a', /a/), false);\n  });\n  it('tests currying', function() {\n    eq(R.has('a')({ a: { b: 1 } }), true);\n  });"},"hasPath":{"method":"hasPath","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('hasPath', function() {\n  var obj = {\n    objVal: {b: {c: 'c'}},\n    falseVal: false,\n    nullVal: null,\n    undefinedVal: undefined,\n    arrayVal: ['arr']\n  };\n  it('returns true for existing path', function() {\n    eq(R.hasPath(['objVal'], obj), true);\n    eq(R.hasPath(['objVal', 'b'], obj), true);\n    eq(R.hasPath(['objVal', 'b', 'c'], obj), true);\n    eq(R.hasPath(['arrayVal'], obj), true);\n  });\n  it('returns true for existing path to falsy values', function() {\n    eq(R.hasPath(['falseVal'], obj), true);\n    eq(R.hasPath(['nullVal'], obj), true);\n    eq(R.hasPath(['undefinedVal'], obj), true);\n  });\n  it('return false for a test for a child to a non-object', function() {\n    eq(R.hasPath(['undefinedVal', 'child', 'grandchild'], obj), false);\n    eq(R.hasPath(['falseVal', 'child', 'grandchild'], obj), false);\n    eq(R.hasPath(['nullVal', 'child', 'grandchild'], obj), false);\n    eq(R.hasPath(['arrayVal', 0, 'child', 'grandchild'], obj), false);\n  });\n  it('returns true for existing path with indexes', function() {\n    eq(R.hasPath(['arrayVal', 0], obj), true);\n  });\n  it('returns false for non-existing path with indexes', function() {\n    eq(R.hasPath(['arrayVal', 1], obj), false);\n  });\n  it('tests for paths in arrays', function() {\n    eq(R.hasPath([0], [1, 2]), true);\n    eq(R.hasPath([2], [1, 2]), false);\n    eq(R.hasPath(['0'], [1, 2]), true);\n    eq(R.hasPath(['2'], [1, 2]), false);\n  });\n  it('returns false for non-existent path', function() {\n    eq(R.hasPath(['Unknown'], obj), false);\n    eq(R.hasPath(['objVal', 'Unknown'], obj), false);\n  });\n  it('does not check properties from the prototype chain', function() {\n    var Person = function() {};\n    Person.prototype.age = {x: 1};\n    var bob = new Person();\n    eq(R.hasPath(['age'], bob), false);\n    eq(R.hasPath(['age', 'x'], bob), false);\n    eq(R.hasPath(['toString'], bob), false);\n  });\n  it('returns false for non-objects', function() {\n    eq(R.hasPath([], obj), false);\n  });\n  it('tests paths on non-objects', function() {\n    eq(R.hasPath(['a', 'b'], undefined), false);\n    eq(R.hasPath(['a', 'b'], null), false);\n    eq(R.hasPath('a', true), false);\n    eq(R.hasPath('a', ''), false);\n    eq(R.hasPath('a', /a/), false);\n  });\n  it('tests currying', function() {\n    eq(R.hasPath(['a', 'b'])({ a: { b: 1 } }), true);\n  });"},"head":{"method":"head","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('head', function() {\n  it('returns the first element of an ordered collection', function() {\n    eq(R.head([1, 2, 3]), 1);\n    eq(R.head([2, 3]), 2);\n    eq(R.head([3]), 3);\n    eq(R.head([]), undefined);\n    eq(R.head('abc'), 'a');\n    eq(R.head('bc'), 'b');\n    eq(R.head('c'), 'c');\n    eq(R.head(''), '');\n  });\n  it('throws if applied to null or undefined', function() {\n    assert.throws(function() { R.head(null); }, TypeError);\n    assert.throws(function() { R.head(undefined); }, TypeError);\n  });"},"identical":{"method":"identical","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('identical', function() {\n  var a = [];\n  var b = a;\n  it('has Object.is semantics', function() {\n    eq(R.identical(100, 100), true);\n    eq(R.identical(100, '100'), false);\n    eq(R.identical('string', 'string'), true);\n    eq(R.identical([], []), false);\n    eq(R.identical(a, b), true);\n    eq(R.identical(undefined, undefined), true);\n    eq(R.identical(null, undefined), false);\n    eq(R.identical(-0, 0), false);\n    eq(R.identical(0, -0), false);\n    eq(R.identical(NaN, NaN), true);\n    eq(R.identical(NaN, 42), false);\n    eq(R.identical(42, NaN), false);\n    eq(R.identical(0, new Number(0)), false);\n    eq(R.identical(new Number(0), 0), false);\n    eq(R.identical(new Number(0), new Number(0)), false);\n  });"},"identity":{"method":"identity","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('identity', function() {\n  it('returns its first argument', function() {\n    eq(R.identity(undefined), undefined);\n    eq(R.identity('foo'), 'foo');\n    eq(R.identity('foo', 'bar'), 'foo');\n  });\n  it('has length 1', function() {\n    eq(R.identity.length, 1);\n  });"},"ifElse":{"diffReason":"Rambda method doesn't return a curried function","method":"ifElse","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('ifElse', function() {\n  var t = function(a) { return a + 1; };\n  var identity = function(a) { return a; };\n  var isArray = function(a) { return Object.prototype.toString.call(a) === '[object Array]'; };\n  it('calls the truth case function if the validator returns a truthy value', function() {\n    var v = function(a) { return typeof a === 'number'; };\n    eq(R.ifElse(v, t, identity)(10), 11);\n  });\n  it('calls the false case function if the validator returns a falsy value', function() {\n    var v = function(a) { return typeof a === 'number'; };\n    eq(R.ifElse(v, t, identity)('hello'), 'hello');\n  });\n  it('calls the true case on array items and the false case on non array items', function() {\n    var list = [[1, 2, 3, 4, 5], 10, [0, 1], 15];\n    var arrayToLength = R.map(R.ifElse(isArray, R.prop('length'), identity));\n    eq(arrayToLength(list), [5, 10, 2, 15]);\n  });\n  it('passes the arguments to the true case function', function() {\n    var v = function() { return true; };\n    var onTrue = function(a, b) {\n      eq(a, 123);\n      eq(b, 'abc');\n    };\n    R.ifElse(v, onTrue, identity)(123, 'abc');\n  });\n  it('passes the arguments to the false case function', function() {\n    var v = function() { return false; };\n    var onFalse = function(a, b) {\n      eq(a, 123);\n      eq(b, 'abc');\n    };\n    R.ifElse(v, identity, onFalse)(123, 'abc');\n  });\n  it('returns a function whose arity equals the max arity of the three arguments to `ifElse`', function() {\n    function a0() { return 0; }\n    function a1(x) { return x; }\n    function a2(x, y) { return x + y; }\n    eq(R.ifElse(a0, a1, a2).length, 2);\n    eq(R.ifElse(a0, a2, a1).length, 2);\n    eq(R.ifElse(a1, a0, a2).length, 2);\n    eq(R.ifElse(a1, a2, a0).length, 2);\n    eq(R.ifElse(a2, a0, a1).length, 2);\n    eq(R.ifElse(a2, a1, a0).length, 2);\n  });\n  it('returns a curried function', function() {\n    var v = function(a) { return typeof a === 'number'; };\n    var ifIsNumber = R.ifElse(v);\n    eq(ifIsNumber(t, identity)(15), 16);\n    eq(ifIsNumber(t, identity)('hello'), 'hello');\n    var fn = R.ifElse(R.gt, R.subtract, R.add);\n    eq(fn(2)(7), 9);\n    eq(fn(2, 7), 9);\n    eq(fn(7)(2), 5);\n    eq(fn(7, 2), 5);\n  });"},"inc":{"method":"inc","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('inc', function() {\n  it('increments its argument', function() {\n    eq(R.inc(-1), 0);\n    eq(R.inc(0), 1);\n    eq(R.inc(1), 2);\n    eq(R.inc(12.34), 13.34);\n    eq(R.inc(-Infinity), -Infinity);\n    eq(R.inc(Infinity), Infinity);\n  });"},"includes":{"diffReason":"Ramda method pass to `equals` method if available","method":"includes","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('includes', function() {\n  it('returns true if an element is in a list', function() {\n    eq(R.includes(7, [1, 2, 3, 9, 8, 7, 100, 200, 300]), true);\n  });\n  it('returns false if an element is not in a list', function() {\n    eq(R.includes(99, [1, 2, 3, 9, 8, 7, 100, 200, 300]), false);\n  });\n  it('returns false for the empty list', function() {\n    eq(R.includes(1, []), false);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.includes(0, [-0]), false);\n    eq(R.includes(-0, [0]), false);\n    eq(R.includes(NaN, [NaN]), true);\n    eq(R.includes(new Just([42]), [new Just([42])]), true);\n  });\n  it('returns true if substring is part of string', function() {\n    eq(R.includes('ba', 'banana'), true);\n  });"},"indexBy":{"diffReason":"Ramda method can act as a transducer","method":"indexBy","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('indexBy', function() {\n  it('indexes list by the given property', function() {\n    var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n    var indexed = R.indexBy(R.prop('id'), list);\n    eq(indexed, {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}});\n  });\n  it('indexes list by the given property upper case', function() {\n    var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n    var indexed = R.indexBy(R.compose(R.toUpper, R.prop('id')), list);\n    eq(indexed, {ABC: {id: 'abc', title: 'B'}, XYZ: {id: 'xyz', title: 'A'}});\n  });\n  it('can act as a transducer', function() {\n    var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];\n    var transducer = R.compose(\n      R.indexBy(R.prop('id')),\n      R.map(R.pipe(\n        R.adjust(0, R.toUpper),\n        R.adjust(1, R.omit(['id']))\n      )));\n    var result = R.into({}, transducer, list);\n    eq(result, {ABC: {title: 'B'}, XYZ: {title: 'A'}});\n  });"},"indexOf":{"diffReason":"Ramda method dispatches to `indexOf` method","method":"indexOf","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('indexOf', function() {\n  it(\"returns a number indicating an object's position in a list\", function() {\n    var list = [0, 10, 20, 30];\n    eq(R.indexOf(30, list), 3);\n  });\n  it('returns -1 if the object is not in the list', function() {\n    var list = [0, 10, 20, 30];\n    eq(R.indexOf(40, list), -1);\n  });\n  var input = [1, 2, 3, 4, 5];\n  it('returns the index of the first item', function() {\n    eq(R.indexOf(1, input), 0);\n  });\n  it('returns the index of the last item', function() {\n    eq(R.indexOf(5, input), 4);\n  });\n  var list = [1, 2, 3];\n  list[-2] = 4; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('finds 1', function() {\n    eq(R.indexOf(1, list), 0);\n  });\n  it('finds 1 and is result strictly it', function() {\n    eq(R.indexOf(1, list), 0);\n  });\n  it('does not find 4', function() {\n    eq(R.indexOf(4, list), -1);\n  });\n  it('does not consider \"1\" equal to 1', function() {\n    eq(R.indexOf('1', list), -1);\n  });\n  it('returns -1 for an empty array', function() {\n    eq(R.indexOf('x', []), -1);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.indexOf(0, [-0]), -1);\n    eq(R.indexOf(-0, [0]), -1);\n    eq(R.indexOf(NaN, [NaN]), 0);\n    eq(R.indexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `indexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.indexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.indexOf = function(x) {\n      var idx = this.tail.indexOf(x);\n      return this.head === x ? 0 : idx >= 0 ? 1 + idx : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.indexOf('a', 'banana'), 1);\n    eq(R.indexOf('x', 'banana'), -1);\n    eq(R.indexOf('a', list), 1);\n    eq(R.indexOf('x', list), -1);\n  });\n  it('finds function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var list = [g, f, g, f];\n    eq(R.indexOf(f, list), 1);\n  });\n  it('does not find function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var h = function() {};\n    var list = [g, f];\n    eq(R.indexOf(h, list), -1);\n  });"},"init":{"method":"init","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('init', function() {\n  it('returns all but the last element of an ordered collection', function() {\n    eq(R.init([1, 2, 3]), [1, 2]);\n    eq(R.init([2, 3]), [2]);\n    eq(R.init([3]), []);\n    eq(R.init([]), []);\n    eq(R.init('abc'), 'ab');\n    eq(R.init('bc'), 'b');\n    eq(R.init('c'), '');\n    eq(R.init(''), '');\n  });\n  it('throws if applied to null or undefined', function() {\n    assert.throws(function() { R.init(null); }, TypeError);\n    assert.throws(function() { R.init(undefined); }, TypeError);\n  });\n  it('handles array-like object', function() {\n    var args = (function() { return arguments; }(1, 2, 3, 4, 5));\n    eq(R.init(args), [1, 2, 3, 4]);\n  });"},"intersection":{"method":"intersection","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('intersection', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  it('combines two lists into the set of common elements', function() {\n    eq(R.intersection(M, N), [3, 4]);\n  });\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.intersection(M2, N2), [3, 4]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.intersection([0], [-0]).length, 0);\n    eq(R.intersection([-0], [0]).length, 0);\n    eq(R.intersection([NaN], [NaN]).length, 1);\n    eq(R.intersection([new Just([42])], [new Just([42])]).length, 1);\n  });"},"intersperse":{"method":"intersperse","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('intersperse', function() {\n  it('interposes a separator between list items', function() {\n    eq(R.intersperse('n', ['ba', 'a', 'a']), ['ba', 'n', 'a', 'n', 'a']);\n    eq(R.intersperse('bar', ['foo']), ['foo']);\n    eq(R.intersperse('bar', []), []);\n  });\n  it('dispatches', function() {\n    var obj = {intersperse: function(x) { return 'override ' + x; }};\n    eq(R.intersperse('x', obj), 'override x');\n  });"},"is":{"method":"is","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('is', function() {\n  it('works with built-in types', function() {\n    eq(R.is(Array, []), true);\n    eq(R.is(Boolean, new Boolean(false)), true);\n    eq(R.is(Date, new Date()), true);\n    eq(R.is(Function, function() {}), true);\n    eq(R.is(Number, new Number(0)), true);\n    eq(R.is(Object, {}), true);\n    eq(R.is(RegExp, /(?:)/), true);\n    eq(R.is(String, new String('')), true);\n  });\n  it('works with user-defined types', function() {\n    function Foo() {}\n    function Bar() {}\n    Bar.prototype = new Foo();\n    var foo = new Foo();\n    var bar = new Bar();\n    eq(R.is(Foo, foo), true);\n    eq(R.is(Bar, bar), true);\n    eq(R.is(Foo, bar), true);\n    eq(R.is(Bar, foo), false);\n  });\n  it('considers almost everything an object', function() {\n    function Foo() {}\n    var foo = new Foo();\n    var isObject = R.is(Object);\n    eq(isObject(foo), true);\n    eq(isObject((function() { return arguments; })()), true);\n    eq(isObject([]), true);\n    eq(isObject(new Boolean(false)), true);\n    eq(isObject(new Date()), true);\n    eq(isObject(function() {}), true);\n    eq(isObject(new Number(0)), true);\n    eq(isObject(/(?:)/), true);\n    eq(isObject(new String('')), true);\n    eq(isObject(Object.create(null)), true);\n    eq(isObject(null), false);\n    eq(isObject(undefined), false);\n  });\n  it('does not coerce', function() {\n    eq(R.is(Boolean, 1), false);\n    eq(R.is(Number, '1'), false);\n    eq(R.is(Number, false), false);\n  });\n  it('recognizes primitives as their object equivalents', function() {\n    eq(R.is(Boolean, false), true);\n    eq(R.is(Number, 0), true);\n    eq(R.is(String, ''), true);\n  });\n  it('does not consider primitives to be instances of Object', function() {\n    eq(R.is(Object, false), false);\n    eq(R.is(Object, 0), false);\n    eq(R.is(Object, ''), false);\n  });"},"isEmpty":{"diffReason":"Ramda method supports typed arrays","method":"isEmpty","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('isEmpty', function() {\n  it('returns false for null', function() {\n    eq(R.isEmpty(null), false);\n  });\n  it('returns false for undefined', function() {\n    eq(R.isEmpty(undefined), false);\n  });\n  it('returns true for empty string', function() {\n    eq(R.isEmpty(''), true);\n    eq(R.isEmpty(' '), false);\n  });\n  it('returns true for empty array', function() {\n    eq(R.isEmpty([]), true);\n    eq(R.isEmpty([[]]), false);\n  });\n  it('returns true for empty typed array', function() {\n    eq(R.isEmpty(Uint8Array.from('')), true);\n    eq(R.isEmpty(Float32Array.from('')), true);\n    eq(R.isEmpty(new Float32Array([])), true);\n    eq(R.isEmpty(Uint8Array.from('1')), false);\n    eq(R.isEmpty(Float32Array.from('1')), false);\n    eq(R.isEmpty(new Float32Array([1])), false);\n  });\n  it('returns true for empty object', function() {\n    eq(R.isEmpty({}), true);\n    eq(R.isEmpty({x: 0}), false);\n  });\n  it('returns true for empty arguments object', function() {\n    eq(R.isEmpty((function() { return arguments; })()), true);\n    eq(R.isEmpty((function() { return arguments; })(0)), false);\n  });\n  it('returns false for every other value', function() {\n    eq(R.isEmpty(0), false);\n    eq(R.isEmpty(NaN), false);\n    eq(R.isEmpty(['']), false);\n  });"},"isNil":{"method":"isNil","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('isNil', function() {\n  it('tests a value for `null` or `undefined`', function() {\n    eq(R.isNil(void 0), true);\n    eq(R.isNil(null), true);\n    eq(R.isNil([]), false);\n    eq(R.isNil({}), false);\n    eq(R.isNil(0), false);\n    eq(R.isNil(''), false);\n  });"},"join":{"method":"join","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('join', function() {\n  it(\"concatenates a list's elements to a string, with an separator string between elements\", function() {\n    var list = [1, 2, 3, 4];\n    eq(R.join('~', list), '1~2~3~4');\n  });"},"keys":{"diffReason":"Ramda method works for primitives","method":"keys","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('keys', function() {\n  var obj = {a: 100, b: [1, 2, 3], c: {x: 200, y: 300}, d: 'D', e: null, f: undefined};\n  function C() { this.a = 100; this.b = 200; }\n  C.prototype.x = function() { return 'x'; };\n  C.prototype.y = 'y';\n  var cobj = new C();\n  it(\"returns an array of the given object's own keys\", function() {\n    eq(R.keys(obj).sort(), ['a', 'b', 'c', 'd', 'e', 'f']);\n  });\n  it('works with hasOwnProperty override', function() {\n    eq(R.keys({\n      hasOwnProperty: false\n    }), ['hasOwnProperty']);\n  });\n  it('works for primitives', function() {\n    eq(R.keys(null), []);\n    eq(R.keys(undefined), []);\n    eq(R.keys(55), []);\n    eq(R.keys('foo'), []);\n    eq(R.keys(true), []);\n    eq(R.keys(false), []);\n    eq(R.keys(NaN), []);\n    eq(R.keys(Infinity), []);\n    eq(R.keys([]), []);\n  });\n  it(\"does not include the given object's prototype properties\", function() {\n    eq(R.keys(cobj).sort(), ['a', 'b']);\n  });"},"last":{"method":"last","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('last', function() {\n  it('returns the last element of an ordered collection', function() {\n    eq(R.last([1, 2, 3]), 3);\n    eq(R.last([1, 2]), 2);\n    eq(R.last([1]), 1);\n    eq(R.last([]), undefined);\n    eq(R.last('abc'), 'c');\n    eq(R.last('ab'), 'b');\n    eq(R.last('a'), 'a');\n    eq(R.last(''), '');\n  });\n  it('throws if applied to null or undefined', function() {\n    assert.throws(function() { R.last(null); }, TypeError);\n    assert.throws(function() { R.last(undefined); }, TypeError);\n  });"},"lastIndexOf":{"diffReason":"Ramda method dispatches to `lastIndexOf` method","method":"lastIndexOf","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('lastIndexOf', function() {\n  it(\"returns a number indicating an object's last position in a list\", function() {\n    var list = [0, 10, 20, 30, 0, 10, 20, 30, 0, 10];\n    eq(R.lastIndexOf(30, list), 7);\n  });\n  it('returns -1 if the object is not in the list', function() {\n    var list = [0, 10, 20, 30];\n    eq(R.lastIndexOf(40, list), -1);\n  });\n  var input = [1, 2, 3, 4, 5, 1];\n  it('returns the last index of the first item', function() {\n    eq(R.lastIndexOf(1, input), 5);\n  });\n  it('returns the index of the last item', function() {\n    eq(R.lastIndexOf(5, input), 4);\n  });\n  var list = ['a', 1, 'a'];\n  list[-2] = 'a'; // Throw a wrench in the gears by assigning a non-valid array index as object property.\n  it('finds a', function() {\n    eq(R.lastIndexOf('a', list), 2);\n  });\n  it('does not find c', function() {\n    eq(R.lastIndexOf('c', list), -1);\n  });\n  it('does not consider \"1\" equal to 1', function() {\n    eq(R.lastIndexOf('1', list), -1);\n  });\n  it('returns -1 for an empty array', function() {\n    eq(R.lastIndexOf('x', []), -1);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.lastIndexOf(0, [-0]), -1);\n    eq(R.lastIndexOf(-0, [0]), -1);\n    eq(R.lastIndexOf(NaN, [NaN]), 0);\n    eq(R.lastIndexOf(new Just([42]), [new Just([42])]), 0);\n  });\n  it('dispatches to `lastIndexOf` method', function() {\n    function Empty() {}\n    Empty.prototype.lastIndexOf = R.always(-1);\n    function List(head, tail) {\n      this.head = head;\n      this.tail = tail;\n    }\n    List.prototype.lastIndexOf = function(x) {\n      var idx = this.tail.lastIndexOf(x);\n      return idx >= 0 ? 1 + idx : this.head === x ? 0 : -1;\n    };\n    var list = new List('b',\n      new List('a',\n        new List('n',\n          new List('a',\n            new List('n',\n              new List('a',\n                new Empty()\n              )\n            )\n          )\n        )\n      )\n    );\n    eq(R.lastIndexOf('a', 'banana'), 5);\n    eq(R.lastIndexOf('x', 'banana'), -1);\n    eq(R.lastIndexOf('a', list), 5);\n    eq(R.lastIndexOf('x', list), -1);\n  });\n  it('finds function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var list = [g, f, g, f];\n    eq(R.lastIndexOf(f, list), 3);\n  });\n  it('does not find function, compared by identity', function() {\n    var f = function() {};\n    var g = function() {};\n    var h = function() {};\n    var list = [g, f];\n    eq(R.lastIndexOf(h, list), -1);\n  });"},"length":{"diffReason":"Ramda method supports object with `length` method","method":"length","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('length', function() {\n  it('returns the length of a list', function() {\n    eq(R.length([]), 0);\n    eq(R.length(['a', 'b', 'c', 'd']), 4);\n  });\n  it('returns the length of a string', function() {\n    eq(R.length(''), 0);\n    eq(R.length('xyz'), 3);\n  });\n  it('returns the length of a function', function() {\n    eq(R.length(function() {}), 0);\n    eq(R.length(function(x, y, z) { return z; }), 3);\n  });\n  it('returns the length of an arguments object', function() {\n    eq(R.length((function() { return arguments; })()), 0);\n    eq(R.length((function() { return arguments; })('x', 'y', 'z')), 3);\n  });\n  it('returns NaN for value of unexpected type', function() {\n    eq(R.identical(NaN, R.length(0)), true);\n    eq(R.identical(NaN, R.length({})), true);\n    eq(R.identical(NaN, R.length(null)), true);\n    eq(R.identical(NaN, R.length(undefined)), true);\n  });\n  it('returns NaN for length property of unexpected type', function() {\n    eq(R.identical(NaN, R.length({length: ''})), true);\n    eq(R.identical(NaN, R.length({length: '1.23'})), true);\n    eq(R.identical(NaN, R.length({length: null})), true);\n    eq(R.identical(NaN, R.length({length: undefined})), true);\n    eq(R.identical(NaN, R.length({})), true);\n  });"},"lensIndex":{"method":"lensIndex","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\nvar testList = [{a: 1}, {b: 2}, {c: 3}];\ndescribe('lensIndex', function() {\n  describe('view', function() {\n    it('focuses list element at the specified index', function() {\n      eq(R.view(R.lensIndex(0), testList), {a: 1});\n    });\n    it('returns undefined if the specified index does not exist', function() {\n      eq(R.view(R.lensIndex(10), testList), undefined);\n    });\n  });\n  describe('set', function() {\n    it('sets the list value at the specified index', function() {\n      eq(R.set(R.lensIndex(0), 0, testList), [0, {b: 2}, {c: 3}]);\n    });\n  });\n  describe('over', function() {\n    it('applies function to the value at the specified list index', function() {\n      eq(R.over(R.lensIndex(2), R.keys, testList), [{a: 1}, {b: 2}, ['c']]);\n    });\n  });\n  describe('composability', function() {\n    it('can be composed', function() {\n      var nestedList = [0, [10, 11, 12], 1, 2];\n      var composedLens = R.compose(R.lensIndex(1), R.lensIndex(0));\n      eq(R.view(composedLens, nestedList), 10);\n    });\n  });\n  describe('well behaved lens', function() {\n    it('set s (get s) === s', function() {\n      eq(R.set(R.lensIndex(0), R.view(R.lensIndex(0), testList), testList), testList);\n    });\n    it('get (set s v) === v', function() {\n      eq(R.view(R.lensIndex(0), R.set(R.lensIndex(0), 0, testList)), 0);\n    });\n    it('get (set(set s v1) v2) === v2', function() {\n      eq(\n        R.view(R.lensIndex(0), R.set(R.lensIndex(0), 11, R.set(R.lensIndex(0), 10, testList))),\n        11\n      );\n    });\n  });"},"lensPath":{"method":"lensPath","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\nvar testObj = {\n  a: [{\n    b: 1\n  }, {\n    b: 2\n  }],\n  d: 3\n};\ndescribe('lensPath', function() {\n  describe('view', function() {\n    it('focuses the specified object property', function() {\n      eq(R.view(R.lensPath(['d']), testObj), 3);\n      eq(R.view(R.lensPath(['a', 1, 'b']), testObj), 2);\n      eq(R.view(R.lensPath([]), testObj), testObj);\n    });\n  });\n  describe('set', function() {\n    it('sets the value of the object property specified', function() {\n      eq(R.set(R.lensPath(['d']), 0, testObj), {a: [{b: 1}, {b: 2}], d: 0});\n      eq(R.set(R.lensPath(['a', 0, 'b']), 0, testObj), {a: [{b: 0}, {b: 2}], d: 3});\n      eq(R.set(R.lensPath([]), 0, testObj), 0);\n    });\n    it('adds the property to the object if it doesn\\'t exist', function() {\n      eq(R.set(R.lensPath(['X']), 0, testObj), {a: [{b: 1}, {b: 2}], d: 3, X: 0});\n      eq(R.set(R.lensPath(['a', 0, 'X']), 0, testObj), {a: [{b: 1, X: 0}, {b: 2}], d: 3});\n    });\n  });\n  describe('over', function() {\n    it('applies function to the value of the specified object property', function() {\n      eq(R.over(R.lensPath(['d']), R.inc, testObj), {a: [{b: 1}, {b: 2}], d: 4});\n      eq(R.over(R.lensPath(['a', 1, 'b']), R.inc, testObj), {a: [{b: 1}, {b: 3}], d: 3});\n      eq(R.over(R.lensPath([]), R.toPairs, testObj), [['a', [{b: 1}, {b: 2}]], ['d', 3]]);\n    });\n    it('applies function to undefined and adds the property if it doesn\\'t exist', function() {\n      eq(R.over(R.lensPath(['X']), R.identity, testObj), {a: [{b: 1}, {b: 2}], d: 3, X: undefined});\n      eq(R.over(R.lensPath(['a', 0, 'X']), R.identity, testObj), {a: [{b: 1, X: undefined}, {b: 2}], d: 3});\n    });\n  });\n  describe('composability', function() {\n    it('can be composed', function() {\n      var composedLens = R.compose(R.lensPath(['a']), R.lensPath([1, 'b']));\n      eq(R.view(composedLens, testObj), 2);\n    });\n  });\n  describe('well behaved lens', function() {\n    it('set s (get s) === s', function() {\n      eq(R.set(R.lensPath(['d']), R.view(R.lensPath(['d']), testObj), testObj), testObj);\n      eq(R.set(R.lensPath(['a', 0, 'b']), R.view(R.lensPath(['a', 0, 'b']), testObj), testObj), testObj);\n    });\n    it('get (set s v) === v', function() {\n      eq(R.view(R.lensPath(['d']), R.set(R.lensPath(['d']), 0, testObj)), 0);\n      eq(R.view(R.lensPath(['a', 0, 'b']), R.set(R.lensPath(['a', 0, 'b']), 0, testObj)), 0);\n    });\n    it('get (set(set s v1) v2) === v2', function() {\n      var p = ['d'];\n      var q = ['a', 0, 'b'];\n      eq(R.view(R.lensPath(p), R.set(R.lensPath(p), 11, R.set(R.lensPath(p), 10, testObj))), 11);\n      eq(R.view(R.lensPath(q), R.set(R.lensPath(q), 11, R.set(R.lensPath(q), 10, testObj))), 11);\n    });\n  });"},"lensProp":{"method":"lensProp","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\nvar testObj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\ndescribe('lensProp', function() {\n  describe('view', function() {\n    it('focuses object the specified object property', function() {\n      eq(R.view(R.lensProp('a'), testObj), 1);\n    });\n    it('returns undefined if the specified property does not exist', function() {\n      eq(R.view(R.lensProp('X'), testObj), undefined);\n    });\n  });\n  describe('set', function() {\n    it('sets the value of the object property specified', function() {\n      eq(R.set(R.lensProp('a'), 0, testObj), {a:0, b:2, c:3});\n    });\n    it('adds the property to the object if it doesn\\'t exist', function() {\n      eq(R.set(R.lensProp('d'), 4, testObj), {a:1, b:2, c:3, d:4});\n    });\n  });\n  describe('over', function() {\n    it('applies function to the value of the specified object property', function() {\n      eq(R.over(R.lensProp('a'), R.inc, testObj), {a:2, b:2, c:3});\n    });\n    it('applies function to undefined and adds the property if it doesn\\'t exist', function() {\n      eq(R.over(R.lensProp('X'), R.identity, testObj), {a:1, b:2, c:3, X:undefined});\n    });\n  });\n  describe('composability', function() {\n    it('can be composed', function() {\n      var nestedObj = {a: {b: 1}, c:2};\n      var composedLens = R.compose(R.lensProp('a'), R.lensProp('b'));\n      eq(R.view(composedLens, nestedObj), 1);\n    });\n  });\n  describe('well behaved lens', function() {\n    it('set s (get s) === s', function() {\n      eq(R.set(R.lensProp('a'), R.view(R.lensProp('a'), testObj), testObj), testObj);\n    });\n    it('get (set s v) === v', function() {\n      eq(R.view(R.lensProp('a'), R.set(R.lensProp('a'), 0, testObj)), 0);\n    });\n    it('get (set(set s v1) v2) === v2', function() {\n      eq(\n        R.view(R.lensProp('a'), R.set(R.lensProp('a'), 11, R.set(R.lensProp('a'), 10, testObj))),\n        11\n      );\n    });\n  });"},"map":{"method":"map","content":"var listXf = require('./helpers/listXf');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar assert = require('assert');\nvar eq = require('./shared/eq');\nvar Id = require('./shared/Id');\ndescribe('map', function() {\n  var times2 = function(x) {return x * 2;};\n  var add1 = function(x) {return x + 1;};\n  var dec = function(x) { return x - 1; };\n  var intoArray = R.into([]);\n  it('maps simple functions over arrays', function() {\n    eq(R.map(times2, [1, 2, 3, 4]), [2, 4, 6, 8]);\n  });\n  it('maps simple functions into arrays', function() {\n    eq(intoArray(R.map(times2), [1, 2, 3, 4]), [2, 4, 6, 8]);\n  });\n  it('maps over objects', function() {\n    eq(R.map(dec, {}), {});\n    eq(R.map(dec, {x: 4, y: 5, z: 6}), {x: 3, y: 4, z: 5});\n  });\n  it('interprets ((->) r) as a functor', function() {\n    var f = function(a) { return a - 1; };\n    var g = function(b) { return b * 2; };\n    var h = R.map(f, g);\n    eq(h(10), (10 * 2) - 1);\n  });\n  it('dispatches to objects that implement `map`', function() {\n    var obj = {x: 100, map: function(f) { return f(this.x); }};\n    eq(R.map(add1, obj), 101);\n  });\n  it('dispatches to transformer objects', function() {\n    eq(R.map(add1, listXf), {\n      f: add1,\n      xf: listXf\n    });\n  });\n  it('throws a TypeError on null and undefined', function() {\n    assert.throws(function() { return R.map(times2, null); }, TypeError);\n    assert.throws(function() { return R.map(times2, undefined); }, TypeError);\n  });\n  it('composes', function() {\n    var mdouble = R.map(times2);\n    var mdec = R.map(dec);\n    eq(mdec(mdouble([10, 20, 30])), [19, 39, 59]);\n  });\n  it('can compose transducer-style', function() {\n    var mdouble = R.map(times2);\n    var mdec = R.map(dec);\n    var xcomp = mdec(mdouble(listXf));\n    eq(xcomp.xf, {xf: listXf, f: times2});\n    eq(xcomp.f, dec);\n  });\n  it('correctly uses fantasy-land implementations', function() {\n    var m1 = Id(1);\n    var m2 = R.map(R.add(1), m1);\n    eq(m1.value + 1, m2.value);\n  });"},"match":{"method":"match","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('match', function() {\n  var re = /[A-Z]\\d\\d\\-[a-zA-Z]+/;\n  var matching = 'B17-afn';\n  var notMatching = 'B1-afn';\n  it('determines whether a string matches a regex', function() {\n    eq(R.match(re, matching).length, 1);\n    eq(R.match(re, notMatching), []);\n  });\n  it('defaults to a different empty array each time', function() {\n    var first = R.match(re, notMatching);\n    var second = R.match(re, notMatching);\n    assert.notStrictEqual(first, second);\n  });\n  it('throws on null input', function() {\n    assert.throws(function shouldThrow() { R.match(re, null); }, TypeError);\n  });"},"mathMod":{"method":"mathMod","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('mathMod', function() {\n  it('requires integer arguments', function() {\n    assert(Number.isNaN(R.mathMod('s', 3)));\n    assert(Number.isNaN(R.mathMod(3, 's')));\n    assert(Number.isNaN(R.mathMod(12.2, 3)));\n    assert(Number.isNaN(R.mathMod(3, 12.2)));\n  });\n  it('behaves differently than JS modulo', function() {\n    assert.notStrictEqual(R.mathMod(-17, 5), -17 % 5);\n    assert.notStrictEqual(R.mathMod(17.2, 5), 17.2 % 5);\n    assert.notStrictEqual(R.mathMod(17, -5), 17 % -5);\n  });\n  it('computes the true modulo function', function() {\n    eq(R.mathMod(-17, 5), 3);\n    eq(R.identical(NaN, R.mathMod(17, -5)), true);\n    eq(R.identical(NaN, R.mathMod(17, 0)), true);\n    eq(R.identical(NaN, R.mathMod(17.2, 5)), true);\n    eq(R.identical(NaN, R.mathMod(17, 5.5)), true);\n  });"},"max":{"method":"max","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('max', function() {\n  it('returns the larger of its two arguments', function() {\n    eq(R.max(-7, 7), 7);\n    eq(R.max(7, -7), 7);\n  });\n  it('works for any orderable type', function() {\n    var d1 = new Date('2001-01-01');\n    var d2 = new Date('2002-02-02');\n    eq(R.max(d1, d2), d2);\n    eq(R.max(d2, d1), d2);\n    eq(R.max('a', 'b'), 'b');\n    eq(R.max('b', 'a'), 'b');\n  });"},"maxBy":{"method":"maxBy","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('maxBy', function() {\n  it('returns the larger value as determined by the function', function() {\n    eq(R.maxBy(function(n) { return n * n; }, -3, 2), -3);\n    eq(R.maxBy(R.prop('x'), {x: 3, y: 1}, {x: 5, y: 10}), {x: 5, y: 10});\n  });"},"mean":{"method":"mean","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('mean', function() {\n  it('returns mean of a nonempty list', function() {\n    eq(R.mean([2]), 2);\n    eq(R.mean([2, 7]), 4.5);\n    eq(R.mean([2, 7, 9]), 6);\n    eq(R.mean([2, 7, 9, 10]), 7);\n  });\n  it('returns NaN for an empty list', function() {\n    eq(R.identical(NaN, R.mean([])), true);\n  });\n  it('handles array-like object', function() {\n    eq(R.mean((function() { return arguments; })(1, 2, 3)), 2);\n  });"},"median":{"method":"median","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('median', function() {\n  it('returns middle value of an odd-length list', function() {\n    eq(R.median([2]), 2);\n    eq(R.median([2, 9, 7]), 7);\n  });\n  it('returns mean of two middle values of a nonempty even-length list', function() {\n    eq(R.median([7, 2]), 4.5);\n    eq(R.median([7, 2, 10, 9]), 8);\n  });\n  it('returns NaN for an empty list', function() {\n    eq(R.identical(NaN, R.median([])), true);\n  });\n  it('handles array-like object', function() {\n    eq(R.median((function() { return arguments; })(1, 2, 3)), 2);\n  });"},"mergeAll":{"method":"mergeAll","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('mergeAll', function() {\n  it('merges a list of objects together into one object', function() {\n    eq(R.mergeAll([{foo:1}, {bar:2}, {baz:3}]), {foo:1, bar:2, baz:3});\n  });\n  it('gives precedence to later objects in the list', function() {\n    eq(R.mergeAll([{foo:1}, {foo:2}, {bar:2}]), {foo:2, bar:2});\n  });\n  it('ignores inherited properties', function() {\n    function Foo() {}\n    Foo.prototype.bar = 42;\n    var foo = new Foo();\n    var res = R.mergeAll([foo, {fizz: 'buzz'}]);\n    eq(res, {fizz: 'buzz'});\n  });"},"mergeDeepRight":{"method":"mergeDeepRight","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('mergeDeepRight', function() {\n  it('takes two objects, recursively merges their own properties and returns a new object', function() {\n    var a = { w: 1, x: 2, y: { z: 3 }};\n    var b = { a: 4, b: 5, c: { d: 6 }};\n    eq(R.mergeDeepRight(a, b), { w: 1, x: 2, y: { z: 3 }, a: 4, b: 5, c: { d: 6 }});\n  });\n  it('overrides properties in the first object with properties in the second object', function() {\n    var a = { a: { b: 1, c: 2 }, y: 0 };\n    var b = { a: { b: 3, d: 4 }, z: 0 };\n    eq(R.mergeDeepRight(a, b), { a: { b: 3, c: 2, d: 4 }, y: 0, z: 0 });\n  });\n  it('is not destructive', function() {\n    var a = { w: 1, x: { y: 2 }};\n    var res = R.mergeDeepRight(a, { x: { y: 3 }});\n    assert.notStrictEqual(a, res);\n    assert.notStrictEqual(a.x, res.x);\n    eq(res, { w: 1, x: { y: 3 }});\n  });\n  it('reports only own properties', function() {\n    var a = { w: 1, x: { y: 2 }};\n    function Cla() {}\n    Cla.prototype.y = 5;\n    eq(R.mergeDeepRight({ x: new Cla() }, a), { w: 1, x: { y: 2 }});\n    eq(R.mergeDeepRight(a, { x: new Cla() }), { w: 1, x: { y: 2 }});\n  });"},"mergeLeft":{"method":"mergeLeft","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('mergeLeft', function() {\n  it('takes two objects, merges their own properties and returns a new object', function() {\n    var a = {w: 1, x: 2};\n    var b = {y: 3, z: 4};\n    eq(R.mergeLeft(a, b), {w: 1, x: 2, y: 3, z: 4});\n  });\n  it('overrides properties in the second object with properties in the first object', function() {\n    var a = {w: 1, x: 2};\n    var b = {w: 100, y: 3, z: 4};\n    eq(R.mergeLeft(a, b), {w: 1, x: 2, y: 3, z: 4});\n  });\n  it('is not destructive', function() {\n    var a = {w: 1, x: 2};\n    var res = R.mergeLeft(a, {x: 3, y: 4});\n    assert.notStrictEqual(a, res);\n    eq(res, {w: 1, x: 2, y: 4});\n  });\n  it('reports only own properties', function() {\n    var a = {w: 1, x: 2};\n    function Cla() {}\n    Cla.prototype.x = 5;\n    eq(R.mergeLeft(new Cla(), a), {w: 1, x: 2});\n    eq(R.mergeLeft(a, new Cla()), {w: 1, x: 2});\n  });\n  it('is shallow', function() {\n    var a = { x: { u: 1, v: 2 }, y: 0 };\n    var b = { x: { u: 3, w: 4 }, z: 0 };\n    var res = R.mergeLeft(a, b);\n    assert.strictEqual(a.x, res.x);\n    eq(res, { x: { u: 1, v: 2 }, y: 0, z: 0 });\n  });"},"min":{"method":"min","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('min', function() {\n  it('returns the smaller of its two arguments', function() {\n    eq(R.min(-7, 7), -7);\n    eq(R.min(7, -7), -7);\n  });\n  it('works for any orderable type', function() {\n    var d1 = new Date('2001-01-01');\n    var d2 = new Date('2002-02-02');\n    eq(R.min(d1, d2), d1);\n    eq(R.min(d2, d1), d1);\n    eq(R.min('a', 'b'), 'a');\n    eq(R.min('b', 'a'), 'a');\n  });"},"minBy":{"method":"minBy","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('minBy', function() {\n  it('returns the smaller value as determined by the function', function() {\n    eq(R.minBy(function(n) { return n * n; }, -3, 2), 2);\n    eq(R.minBy(R.prop('x'), {x: 3, y: 1}, {x: 5, y: 10}), {x: 3, y: 1});\n  });"},"modulo":{"method":"modulo","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('modulo', function() {\n  it('divides the first param by the second and returns the remainder', function() {\n    eq(R.modulo(100, 2), 0);\n    eq(R.modulo(100, 3), 1);\n    eq(R.modulo(100, 17), 15);\n  });\n  it('preserves javascript-style modulo evaluation for negative numbers', function() {\n    eq(R.modulo(-5, 4), -1);\n  });"},"move":{"diffReason":"Ramda method does not support negative indexes","method":"move","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\nvar list = ['a', 'b', 'c', 'd', 'e', 'f'];\ndescribe('move', function() {\n  it('moves an element from an index to another', function() {\n    eq(R.move(0, 1, list), ['b', 'a', 'c', 'd', 'e', 'f']);\n    eq(R.move(2, 1, list), ['a', 'c', 'b', 'd', 'e', 'f']);\n    eq(R.move(-1, 0, list), ['f', 'a', 'b', 'c', 'd', 'e']);\n    eq(R.move(0, -1, list), ['b', 'c', 'd', 'e', 'f', 'a']);\n  });\n  it('does nothing when indexes are outside the list outbounds', function() {\n    eq(R.move(-20, 2, list), list);\n    eq(R.move(20, 2, list), list);\n    eq(R.move(2, 20, list), list);\n    eq(R.move(2, -20, list), list);\n    eq(R.move(20, 20, list), list);\n    eq(R.move(-20, -20, list), list);\n  });"},"multiply":{"method":"multiply","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('multiply', function() {\n  it('multiplies together two numbers', function() {\n    eq(R.multiply(6, 7), 42);\n  });"},"negate":{"method":"negate","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('negate', function() {\n  it('negates its argument', function() {\n    eq(R.negate(-Infinity), Infinity);\n    eq(R.negate(-1), 1);\n    eq(R.negate(-0), 0);\n    eq(R.negate(0), -0);\n    eq(R.negate(1), -1);\n    eq(R.negate(Infinity), -Infinity);\n  });"},"none":{"method":"none","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('none', function() {\n  var even = function(n) {return n % 2 === 0;};\n  var T = function() {return true;};\n  var intoArray = R.into([]);\n  it('returns true if no elements satisfy the predicate', function() {\n    eq(R.none(even, [1, 3, 5, 7, 9, 11]), true);\n  });\n  it('returns false if any element satisfies the predicate', function() {\n    eq(R.none(even, [1, 3, 5, 7, 8, 11]), false);\n  });\n  it('returns true for an empty list', function() {\n    eq(R.none(T, []), true);\n  });\n  it('returns into array', function() {\n    eq(intoArray(R.none(even), [1, 3, 5, 7, 9, 11]), [true]);\n    eq(intoArray(R.none(even), [1, 3, 5, 7, 8, 11]), [false]);\n    eq(intoArray(R.none(T), []), [true]);\n  });\n  it('works with more complex objects', function() {\n    var xs = [{x: 'abcd'}, {x: 'adef'}, {x: 'fghiajk'}];\n    function len3(o) { return o.x.length === 3; }\n    function hasA(o) { return o.x.indexOf('a') >= 0; }\n    eq(R.none(len3, xs), true);\n    eq(R.none(hasA, xs), false);\n  });"},"not":{"method":"not","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('not', function() {\n  it('reverses argument', function() {\n    eq(R.not(false), true);\n    eq(R.not(1), false);\n    eq(R.not(''), true);\n  });"},"nth":{"method":"nth","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('nth', function() {\n  var list = ['foo', 'bar', 'baz', 'quux'];\n  it('accepts positive offsets', function() {\n    eq(R.nth(0, list), 'foo');\n    eq(R.nth(1, list), 'bar');\n    eq(R.nth(2, list), 'baz');\n    eq(R.nth(3, list), 'quux');\n    eq(R.nth(4, list), undefined);\n    eq(R.nth(0, 'abc'), 'a');\n    eq(R.nth(1, 'abc'), 'b');\n    eq(R.nth(2, 'abc'), 'c');\n    eq(R.nth(3, 'abc'), '');\n  });\n  it('accepts negative offsets', function() {\n    eq(R.nth(-1, list), 'quux');\n    eq(R.nth(-2, list), 'baz');\n    eq(R.nth(-3, list), 'bar');\n    eq(R.nth(-4, list), 'foo');\n    eq(R.nth(-5, list), undefined);\n    eq(R.nth(-1, 'abc'), 'c');\n    eq(R.nth(-2, 'abc'), 'b');\n    eq(R.nth(-3, 'abc'), 'a');\n    eq(R.nth(-4, 'abc'), '');\n  });\n  it('throws if applied to null or undefined', function() {\n    assert.throws(function() { R.nth(0, null); }, TypeError);\n    assert.throws(function() { R.nth(0, undefined); }, TypeError);\n  });"},"of":{"method":"of","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('of', function() {\n  it('returns its argument as an Array', function() {\n    eq(R.of(100), [100]);\n    eq(R.of([100]), [[100]]);\n    eq(R.of(null), [null]);\n    eq(R.of(undefined), [undefined]);\n    eq(R.of([]), [[]]);\n  });"},"omit":{"method":"omit","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('omit', function() {\n  var obj = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6};\n  it('copies an object omitting the listed properties', function() {\n    eq(R.omit(['a', 'c', 'f'], obj), {b: 2, d: 4, e: 5});\n  });\n  it('includes prototype properties', function() {\n    var F = function(param) {this.x = param;};\n    F.prototype.y = 40; F.prototype.z = 50;\n    var obj = new F(30);\n    obj.v = 10; obj.w = 20;\n    eq(R.omit(['w', 'x', 'y'], obj), {v: 10, z: 50});\n  });"},"once":{"diffReason":"Ramda method retains arity","method":"once","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('once', function() {\n  it('returns a function that calls the supplied function only the first time called', function() {\n    var ctr = 0;\n    var fn = R.once(function() {ctr += 1;});\n    fn();\n    eq(ctr, 1);\n    fn();\n    eq(ctr, 1);\n    fn();\n    eq(ctr, 1);\n  });\n  it('passes along arguments supplied', function() {\n    var fn = R.once(function(a, b) {return a + b;});\n    var result = fn(5, 10);\n    eq(result, 15);\n  });\n  it('retains and returns the first value calculated, even if different arguments are passed later', function() {\n    var ctr = 0;\n    var fn = R.once(function(a, b) {ctr += 1; return a + b;});\n    var result = fn(5, 10);\n    eq(result, 15);\n    eq(ctr, 1);\n    result = fn(20, 30);\n    eq(result, 15);\n    eq(ctr, 1);\n  });\n  it('retains arity', function() {\n    var f = R.once(function(a, b) { return a + b; });\n    eq(f.length, 2);\n  });"},"or":{"method":"or","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('or', function() {\n  it('compares two values with js ||', function() {\n    eq(R.or(true, true), true);\n    eq(R.or(true, false), true);\n    eq(R.or(false, true), true);\n    eq(R.or(false, false), false);\n  });"},"partial":{"method":"partial","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('partial', function() {\n  var disc = function(a, b, c) { // note disc(3, 7, 4) => 1\n    return b * b - 4 * a * c;\n  };\n  it('caches the initially supplied arguments', function() {\n    var f = R.partial(disc, [3]);\n    eq(f(7, 4), 1);\n    var g = R.partial(disc, [3, 7]);\n    eq(g(4), 1);\n  });\n  it('correctly reports the arity of the new function', function() {\n    var f = R.partial(disc, [3]);\n    eq(f.length, 2);\n    var g = R.partial(disc, [3, 7]);\n    eq(g.length, 1);\n  });"},"partition":{"diffReason":"Ramda library supports fantasy-land","method":"partition","content":"var S = require('sanctuary');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('partition', function() {\n  it('splits a list into two lists according to a predicate', function() {\n    var pred = function(n) { return n % 2; };\n    eq(R.partition(pred, []), [[], []]);\n    eq(R.partition(pred, [0, 2, 4, 6]), [[], [0, 2, 4, 6]]);\n    eq(R.partition(pred, [1, 3, 5, 7]), [[1, 3, 5, 7], []]);\n    eq(R.partition(pred, [0, 1, 2, 3]), [[1, 3], [0, 2]]);\n  });\n  it('works with objects', function() {\n    var pred = function(n) { return n % 2; };\n    eq(R.partition(pred, {}), [{}, {}]);\n    eq(R.partition(pred, { a: 0, b: 2, c: 4, d: 6 }),\n      [{}, { a: 0, b: 2, c: 4, d: 6 }]\n    );\n    eq(R.partition(pred, { a: 1, b: 3, c: 5, d: 7 }),\n      [{ a: 1, b: 3, c: 5, d: 7 }, {}]\n    );\n    eq(R.partition(pred, { a: 0, b: 1, c: 2, d: 3 }),\n      [{ b: 1, d: 3 }, { a: 0, c: 2 }]\n    );\n  });\n  it('works with other filterables', function() {\n    eq(R.partition(R.isEmpty, S.Just(3)),\n      [S.Nothing(), S.Just(3)]\n    );\n    eq(R.partition(R.complement(R.isEmpty), S.Just(3)),\n      [S.Just(3), S.Nothing()]\n    );\n  });"},"path":{"diffReason":"Ramda method supports negative indexes","method":"path","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('path', function() {\n  var deepObject = {a: {b: {c: 'c'}}, falseVal: false, nullVal: null, undefinedVal: undefined, arrayVal: ['arr']};\n  it('takes a path and an object and returns the value at the path or undefined', function() {\n    var obj = {\n      a: {\n        b: {\n          c: 100,\n          d: 200\n        },\n        e: {\n          f: [100, 101, 102],\n          g: 'G'\n        },\n        h: 'H'\n      },\n      i: 'I',\n      j: ['J']\n    };\n    eq(R.path(['a', 'b', 'c'], obj), 100);\n    eq(R.path([], obj), obj);\n    eq(R.path(['a', 'e', 'f', 1], obj), 101);\n    eq(R.path(['j', 0], obj), 'J');\n    eq(R.path(['j', 1], obj), undefined);\n  });\n  it('takes a path that contains indices into arrays', function() {\n    var obj = {\n      a: [[{}], [{x: 'first'}, {x: 'second'}, {x: 'third'}, {x: 'last'}]]\n    };\n    eq(R.path(['a', 0, 0], obj), {});\n    eq(R.path(['a', 0, 1], obj), undefined);\n    eq(R.path(['a', 1, 0, 'x'], obj), 'first');\n    eq(R.path(['a', 1, 1, 'x'], obj), 'second');\n    eq(R.path([0], ['A']), 'A');\n  });\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.path(['x', -2], {x: ['a', 'b', 'c', 'd']}), 'c');\n    eq(R.path([-1, 'y'], [{x: 1, y: 99}, {x: 2, y: 98}, {x: 3, y: 97}]), 97);\n  });\n  it(\"gets a deep property's value from objects\", function() {\n    eq(R.path(['a', 'b', 'c'], deepObject), 'c');\n    eq(R.path(['a'], deepObject), deepObject.a);\n  });\n  it('returns undefined for items not found', function() {\n    eq(R.path(['a', 'b', 'foo'], deepObject), undefined);\n    eq(R.path(['bar'], deepObject), undefined);\n    eq(R.path(['a', 'b'], {a: null}), undefined);\n  });\n  it('works with falsy items', function() {\n    eq(R.path(['toString'], false), Boolean.prototype.toString);\n  });"},"pathEq":{"diffReason":"Ramda library supports fantasy-land","method":"pathEq","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('pathEq', function() {\n  var obj = {\n    a: 1,\n    b: [{\n      ba: 2\n    }, {\n      ba: 3\n    }]\n  };\n  it('returns true if the path matches the value', function() {\n    eq(R.pathEq(['a'], 1, obj), true);\n    eq(R.pathEq(['b', 1, 'ba'], 3, obj), true);\n  });\n  it('returns false for non matches', function() {\n    eq(R.pathEq(['a'], '1', obj), false);\n    eq(R.pathEq(['b', 0, 'ba'], 3, obj), false);\n  });\n  it('returns false for non existing values', function() {\n    eq(R.pathEq(['c'], 'foo', obj), false);\n    eq(R.pathEq(['c', 'd'], 'foo', obj), false);\n  });\n  it('accepts empty path', function() {\n    eq(R.pathEq([], 42, {a: 1, b: 2}), false);\n    eq(R.pathEq([], obj, obj), true);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.pathEq(['value'], 0, {value: -0}), false);\n    eq(R.pathEq(['value'], -0, {value: 0}), false);\n    eq(R.pathEq(['value'], NaN, {value: NaN}), true);\n    eq(R.pathEq(['value'], new Just([42]), {value: new Just([42])}), true);\n  });"},"pathOr":{"method":"pathOr","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('pathOr', function() {\n  var deepObject = {a: {b: {c: 'c'}}, falseVal: false, nullVal: null, undefinedVal: undefined, arrayVal: ['arr']};\n  it('takes a path and an object and returns the value at the path or the default value', function() {\n    var obj = {\n      a: {\n        b: {\n          c: 100,\n          d: 200\n        },\n        e: {\n          f: [100, 101, 102],\n          g: 'G'\n        },\n        h: 'H'\n      },\n      i: 'I',\n      j: ['J']\n    };\n    eq(R.pathOr('Unknown', ['a', 'b', 'c'], obj), 100);\n    eq(R.pathOr('Unknown', [], obj), obj);\n    eq(R.pathOr('Unknown', ['a', 'e', 'f', 1], obj), 101);\n    eq(R.pathOr('Unknown', ['j', 0], obj), 'J');\n    eq(R.pathOr('Unknown', ['j', 1], obj), 'Unknown');\n    eq(R.pathOr('Unknown', ['a', 'b', 'c'], null), 'Unknown');\n  });\n  it(\"gets a deep property's value from objects\", function() {\n    eq(R.pathOr('Unknown', ['a', 'b', 'c'], deepObject), 'c');\n    eq(R.pathOr('Unknown', ['a'], deepObject), deepObject.a);\n  });\n  it('returns the default value for items not found', function() {\n    eq(R.pathOr('Unknown', ['a', 'b', 'foo'], deepObject), 'Unknown');\n    eq(R.pathOr('Unknown', ['bar'], deepObject), 'Unknown');\n  });\n  it('returns the default value for null/undefined', function() {\n    eq(R.pathOr('Unknown', ['toString'], null), 'Unknown');\n    eq(R.pathOr('Unknown', ['toString'], undefined), 'Unknown');\n  });\n  it('works with falsy items', function() {\n    eq(R.pathOr('Unknown', ['toString'], false), Boolean.prototype.toString);\n  });"},"paths":{"diffReason":"Ramda method supports negative indexes","method":"paths","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('paths', function() {\n  var obj = {\n    a: {\n      b: {\n        c: 1,\n        d: 2\n      }\n    },\n    p: [{q: 3}, 'Hi'],\n    x: {\n      y: 'Alice',\n      z: [[{}]]\n    }\n  };\n  it('takes paths and returns values at those paths', function() {\n    eq(R.paths([['a', 'b', 'c'], ['x', 'y']], obj), [1, 'Alice']);\n    eq(R.paths([['a', 'b', 'd'], ['p', 'q']], obj), [2, undefined]);\n  });\n  it('takes a paths that contains indices into arrays', function() {\n    eq(R.paths([['p', 0, 'q'], ['x', 'z', 0, 0]], obj), [3, {}]);\n    eq(R.paths([['p', 0, 'q'], ['x', 'z', 2, 1]], obj), [3, undefined]);\n  });\n  it('takes a path that contains negative indices into arrays', function() {\n    eq(R.paths([['p', -2, 'q'], ['p', -1]], obj), [3, 'Hi']);\n    eq(R.paths([['p', -4, 'q'], ['x', 'z', -1, 0]], obj), [undefined, {}]);\n  });\n  it(\"gets a deep property's value from objects\", function() {\n    eq(R.paths([['a', 'b']], obj), [obj.a.b]);\n    eq(R.paths([['p', 0]], obj), [obj.p[0]]);\n  });\n  it('returns undefined for items not found', function() {\n    eq(R.paths([['a', 'x', 'y']], obj), [undefined]);\n    eq(R.paths([['p', 2]], obj), [undefined]);\n  });"},"pick":{"method":"pick","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('pick', function() {\n  var obj = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, 1: 7};\n  it('copies the named properties of an object to the new object', function() {\n    eq(R.pick(['a', 'c', 'f'], obj), {a: 1, c: 3, f: 6});\n  });\n  it('handles numbers as properties', function() {\n    eq(R.pick([1], obj), {1: 7});\n  });\n  it('ignores properties not included', function() {\n    eq(R.pick(['a', 'c', 'g'], obj), {a: 1, c: 3});\n  });\n  it('retrieves prototype properties', function() {\n    var F = function(param) {this.x = param;};\n    F.prototype.y = 40; F.prototype.z = 50;\n    var obj = new F(30);\n    obj.v = 10; obj.w = 20;\n    eq(R.pick(['w', 'x', 'y'], obj), {w: 20, x: 30, y: 40});\n  });"},"pickAll":{"method":"pickAll","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('pickAll', function() {\n  var obj = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6};\n  it('copies the named properties of an object to the new object', function() {\n    eq(R.pickAll(['a', 'c', 'f'], obj), {a: 1, c: 3, f: 6});\n  });\n  it('includes properties not present on the input object', function() {\n    eq(R.pickAll(['a', 'c', 'g'], obj), {a: 1, c: 3, g: undefined});\n  });"},"pipe":{"diffReason":"Ramda method passes context to functions | Rambda composed functions have no length","method":"pipe","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('pipe', function() {\n  it('is a variadic function', function() {\n    eq(typeof R.pipe, 'function');\n    eq(R.pipe.length, 0);\n  });\n  it('performs left-to-right function composition', function() {\n    //  f :: (String, Number?) -> ([Number] -> [Number])\n    var f = R.pipe(parseInt, R.multiply, R.map);\n    eq(f.length, 2);\n    eq(f('10')([1, 2, 3]), [10, 20, 30]);\n    eq(f('10', 2)([1, 2, 3]), [2, 4, 6]);\n  });\n  it('passes context to functions', function() {\n    function x(val) {\n      return this.x * val;\n    }\n    function y(val) {\n      return this.y * val;\n    }\n    function z(val) {\n      return this.z * val;\n    }\n    var context = {\n      a: R.pipe(x, y, z),\n      x: 4,\n      y: 2,\n      z: 1\n    };\n    eq(context.a(5), 40);\n  });\n  it('throws if given no arguments', function() {\n    assert.throws(\n      function() { R.pipe(); },\n      function(err) {\n        return err.constructor === Error &&\n               err.message === 'pipe requires at least one argument';\n      }\n    );\n  });\n  it('can be applied to one argument', function() {\n    var f = function(a, b, c) { return [a, b, c]; };\n    var g = R.pipe(f);\n    eq(g.length, 3);\n    eq(g(1, 2, 3), [1, 2, 3]);\n  });"},"pluck":{"diffReason":"Ramda method behaves as a transducer","method":"pluck","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('pluck', function() {\n  var people = [\n    {name: 'Fred', age: 23},\n    {name: 'Wilma', age: 21},\n    {name: 'Pebbles', age: 2}\n  ];\n  it('returns a function that maps the appropriate property over an array', function() {\n    var nm = R.pluck('name');\n    eq(typeof nm, 'function');\n    eq(nm(people), ['Fred', 'Wilma', 'Pebbles']);\n  });\n  it('behaves as a transducer when given a transducer in list position', function() {\n    var numbers = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];\n    var transducer = R.compose(R.pluck('a'), R.map(R.add(1)), R.take(2));\n    eq(R.transduce(transducer, R.flip(R.append), [], numbers), [2, 3]);\n  });"},"prepend":{"method":"prepend","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('prepend', function() {\n  it('adds the element to the beginning of the list', function() {\n    eq(R.prepend('x', ['y', 'z']), ['x', 'y', 'z']);\n    eq(R.prepend(['a', 'z'], ['x', 'y']), [['a', 'z'], 'x', 'y']);\n  });\n  it('works on empty list', function() {\n    eq(R.prepend(1, []), [1]);\n  });"},"product":{"method":"product","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('product', function() {\n  it('multiplies together the array of numbers supplied', function() {\n    eq(R.product([1, 2, 3, 4]), 24);\n  });"},"prop":{"method":"prop","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\n\ndescribe('prop', function() {\n  var fred = {name: 'Fred', age: 23};\n  it('returns a function that fetches the appropriate property', function() {\n    var nm = R.prop('name');\n    eq(typeof nm, 'function');\n    eq(nm(fred), 'Fred');\n  });\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.prop(0, deities), 'Cthulhu');\n    eq(R.prop(1, deities), 'Dagon');\n    eq(R.prop(2, deities), 'Yog-Sothoth');\n    eq(R.prop(-1, deities), 'Yog-Sothoth');\n  });\n  it('shows the same behaviour as path for a nonexistent property', function() {\n    var propResult = R.prop('incorrect', fred);\n    var pathResult = R.path(['incorrect'], fred);\n    eq(propResult, pathResult);\n  });\n  it('shows the same behaviour as path for an undefined property', function() {\n    var propResult = R.prop(undefined, fred);\n    var pathResult = R.path([undefined], fred);\n    eq(propResult, pathResult);\n  });\n  it('shows the same behaviour as path for a null property', function() {\n    var propResult = R.prop(null, fred);\n    var pathResult = R.path([null], fred);\n    eq(propResult, pathResult);\n  });\n  it('shows the same behaviour as path for a valid property and object', function() {\n    var propResult = R.prop('age', fred);\n    var pathResult = R.path(['age'], fred);\n    eq(propResult, pathResult);\n  });\n  it('shows the same behaviour as path for a null object', function() {\n    var propResult = R.prop('age', null);\n    var pathResult = R.path(['age'], null);\n    eq(propResult, pathResult);\n  });\n  it('shows the same behaviour as path for an undefined object', function() {\n    var propResult, propException, pathResult, pathException;\n    try {\n      propResult = R.prop('name', undefined);\n    } catch (e) {\n      propException = e;\n    }\n    try {\n      pathResult = R.path(['name'], undefined);\n    } catch (e) {\n      pathException = e;\n    }\n    eq(propResult, pathResult);\n    eq(propException, pathException);\n  });\n  it('returns that value associated to a property given valid one', function() {\n    fc.assert(\n      fc.property(fc.string(), fc.anything(), function(p, value) {\n        const o = { [p]: value };\n        eq(R.prop(p, o), value);\n      })\n    );\n  });\n  it('shows the same behaviour as path on any object', function() {\n    fc.assert(\n      fc.property(fc.string(), fc.object(), function(p, o) {\n        eq(R.prop(p, o), R.path([p], o));\n      })\n    );\n  });\n  it('shows the same behaviour as path on any value', function() {\n    fc.assert(\n      fc.property(fc.string(), fc.anything(), function(p, o) {\n        var propResult, propException, pathResult, pathException;\n        try {\n          propResult = R.prop(p, o);\n        } catch (e) {\n          propException = e;\n        }\n        try {\n          pathResult = R.path([p], o);\n        } catch (e) {\n          pathException = e;\n        }\n        eq(propResult, pathResult);\n        eq(propException, pathException);\n      })\n    );\n  });\n});"},"propEq":{"diffReason":"Ramda method pass to `equals` method if available","method":"propEq","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('propEq', function() {\n  var obj1 = {name: 'Abby', age: 7, hair: 'blond'};\n  var obj2 = {name: 'Fred', age: 12, hair: 'brown'};\n  it('determines whether a particular property matches a given value for a specific object', function() {\n    eq(R.propEq('name', 'Abby', obj1), true);\n    eq(R.propEq('hair', 'brown', obj2), true);\n    eq(R.propEq('hair', 'blond', obj2), false);\n  });\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propEq(0, 'Cthulhu', deities), true);\n    eq(R.propEq(1, 'Dagon', deities), true);\n    eq(R.propEq(2, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(-1, 'Yog-Sothoth', deities), true);\n    eq(R.propEq(3, undefined, deities), true);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.propEq('value', 0, {value: -0}), false);\n    eq(R.propEq('value', -0, {value: 0}), false);\n    eq(R.propEq('value', NaN, {value: NaN}), true);\n    eq(R.propEq('value', new Just([42]), {value: new Just([42])}), true);\n  });\n  it('returns false if called with a null or undefined object', function() {\n    eq(R.propEq('name', 'Abby', null), false);\n    eq(R.propEq('name', 'Abby', undefined), false);\n  });"},"propIs":{"method":"propIs","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('propIs', function() {\n  it('returns true if the specified object property is of the given type', function() {\n    eq(R.propIs(Number, 'value', {value: 1}), true);\n  });\n  it('returns false otherwise', function() {\n    eq(R.propIs(String, 'value', {value: 1}), false);\n    eq(R.propIs(String, 'value', {}), false);\n  });\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propIs(String, 0, deities), true);\n    eq(R.propIs(String, 1, deities), true);\n    eq(R.propIs(String, 2, deities), true);\n    eq(R.propIs(String, -1, deities), true);\n    eq(R.propIs(String, 3, deities), false);\n  });"},"propOr":{"method":"propOr","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('propOr', function() {\n  var fred = {name: 'Fred', age: 23};\n  var anon = {age: 99};\n  var nm = R.propOr('Unknown', 'name');\n  it('returns a function that fetches the appropriate property', function() {\n    eq(typeof nm, 'function');\n    eq(nm(fred), 'Fred');\n  });\n  it('returns the default value when the property does not exist', function() {\n    eq(nm(anon), 'Unknown');\n  });\n  it('returns the default value when the object is nil', function() {\n    eq(nm(null), 'Unknown');\n    eq(nm(void 0), 'Unknown');\n  });\n  it('uses the default when supplied an object with a nil value', function() {\n    eq(R.propOr('foo', 'x', {x: null}), 'foo');\n    eq(R.propOr('foo', 'x', {x: undefined}), 'foo');\n  });\n  it('handles number as property', function() {\n    var deities = ['Cthulhu', 'Dagon', 'Yog-Sothoth'];\n    eq(R.propOr('Unknown', 0, deities), 'Cthulhu');\n    eq(R.propOr('Unknown', 1, deities), 'Dagon');\n    eq(R.propOr('Unknown', 2, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', -1, deities), 'Yog-Sothoth');\n    eq(R.propOr('Unknown', 3, deities), 'Unknown');\n  });\n  it('shows the same behaviour as pathOr for a nonexistent property', function() {\n    var propOrResult = R.propOr('Unknown', 'incorrect', fred);\n    var pathOrResult = R.pathOr('Unknown', ['incorrect'], fred);\n    eq(propOrResult, pathOrResult);\n  });\n  it('shows the same behaviour as pathOr for an undefined property', function() {\n    var propOrResult = R.propOr('Unknown', undefined, fred);\n    var pathOrResult = R.pathOr('Unknown', [undefined], fred);\n    eq(propOrResult, pathOrResult);\n  });\n  it('shows the same behaviour as pathOr for a null property', function() {\n    var propOrResult = R.propOr('Unknown', null, fred);\n    var pathOrResult = R.pathOr('Unknown', [null], fred);\n    eq(propOrResult, pathOrResult);\n  });\n  it('shows the same behaviour as pathOr for a valid property and object', function() {\n    var propOrResult = R.propOr('Unknown', 'age', fred);\n    var pathOrResult = R.pathOr('Unknown', ['age'], fred);\n    eq(propOrResult, pathOrResult);\n  });\n  it('shows the same behaviour as pathOr for a null object', function() {\n    var propOrResult = R.propOr('Unknown', 'age', null);\n    var pathOrResult = R.pathOr('Unknown', ['age'], null);\n    eq(propOrResult, pathOrResult);\n  });\n  it('shows the same behaviour as pathOr for an undefined object', function() {\n    var propOrResult = R.propOr('Unknown', 'age', undefined);\n    var pathOrResult = R.pathOr('Unknown', ['age'], undefined);\n    eq(propOrResult, pathOrResult);\n  });"},"props":{"method":"props","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('props', function() {\n  var obj = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6};\n  it('returns empty array if no properties requested', function() {\n    eq(R.props([], obj), []);\n  });\n  it('returns values for requested properties', function() {\n    eq(R.props(['a', 'e'], obj), [1, 5]);\n  });\n  it('preserves order', function() {\n    eq(R.props(['f', 'c', 'e'], obj), [6, 3, 5]);\n  });\n  it('returns undefined for nonexistent properties', function() {\n    var ps = R.props(['a', 'nonexistent'], obj);\n    eq(ps.length, 2);\n    eq(ps[0], 1);\n    eq(ps[1], void 0);\n  });"},"range":{"method":"range","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('range', function() {\n  it('returns list of numbers', function() {\n    eq(R.range(0, 5), [0, 1, 2, 3, 4]);\n    eq(R.range(4, 7), [4, 5, 6]);\n  });\n  it('returns the empty list if the first parameter is not larger than the second', function() {\n    eq(R.range(7, 3), []);\n    eq(R.range(5, 5), []);\n  });\n  it('returns an empty array if from > to', function() {\n    var result = R.range(10, 5);\n    eq(result, []);\n    result.push(5);\n    eq(R.range(10, 5), []);\n  });\n  it('terminates given bad input', function() {\n    assert.throws(\n      function() { R.range('a', 'z'); },\n      function(err) {\n        return err.constructor === TypeError &&\n               err.message === 'Both arguments to range must be numbers';\n      }\n    );\n  });"},"reduce":{"diffReason":"Rambda library doesn't have `R.reduced` method | Ramda method pass to `reduce` method","method":"reduce","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('reduce', function() {\n  var add = function(a, b) {return a + b;};\n  var mult = function(a, b) {return a * b;};\n  it('folds simple functions over arrays with the supplied accumulator', function() {\n    eq(R.reduce(add, 0, [1, 2, 3, 4]), 10);\n    eq(R.reduce(mult, 1, [1, 2, 3, 4]), 24);\n  });\n  it('dispatches to objects that implement `reduce`', function() {\n    var obj = {x: [1, 2, 3], reduce: function() { return 'override'; }};\n    eq(R.reduce(add, 0, obj), 'override');\n    eq(R.reduce(add, 10, obj), 'override');\n  });\n  it('returns the accumulator for an empty array', function() {\n    eq(R.reduce(add, 0, []), 0);\n    eq(R.reduce(mult, 1, []), 1);\n    eq(R.reduce(R.concat, [], []), []);\n  });\n  it('Prefers the use of the iterator of an object over reduce (and handles short-circuits)', function() {\n    var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';\n    function Reducible(arr) {\n      this.arr = arr;\n    }\n    Reducible.prototype.reduce = function(f, init) {\n      var acc = init;\n      for (var i = 0; i < this.arr.length; i += 1) {\n        acc = f(acc, this.arr[i]);\n      }\n      return acc;\n    };\n    Reducible.prototype[symIterator] = function() {\n      var a = this.arr;\n      return {\n        _pos: 0,\n        next: function() {\n          if (this._pos < a.length) {\n            var v = a[this._pos];\n            this._pos += 1;\n            return {\n              value: v,\n              done: false\n            };\n          } else {\n            return {\n              done: true\n            };\n          }\n        }\n      };\n    };\n    var xf = R.take(2);\n    var apendingT = { };\n    apendingT['@@transducer/result'] = R.identity;\n    apendingT['@@transducer/step'] = R.flip(R.append);\n    var rfn = xf(apendingT);\n    var list = new Reducible([1, 2, 3, 4, 5, 6]);\n    eq(R.reduce(rfn, [], list), [1, 2]);\n  });\n  it('short circuits with reduced', function() {\n    var addWithMaxOf10 = function(acc, val) {return acc + val > 10 ? R.reduced(acc) : acc + val;};\n    eq(R.reduce(addWithMaxOf10, 0, [1, 2, 3, 4]), 10);\n    eq(R.reduce(addWithMaxOf10, 0, [2, 4, 6, 8]), 6);\n  });"},"reject":{"diffReason":"Ramda method dispatches to `filter` method","method":"reject","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('reject', function() {\n  var even = function(x) {return x % 2 === 0;};\n  it('reduces an array to those not matching a filter', function() {\n    eq(R.reject(even, [1, 2, 3, 4, 5]), [1, 3, 5]);\n  });\n  it('returns an empty array if no element matches', function() {\n    eq(R.reject(function(x) { return x < 100; }, [1, 9, 99]), []);\n  });\n  it('returns an empty array if asked to filter an empty array', function() {\n    eq(R.reject(function(x) { return x > 100; }, []), []);\n  });\n  it('returns an empty array if no element matches', function() {\n    eq(R.reject(function(x) { return x < 100; }, [1, 9, 99]), []);\n  });\n  it('returns an empty array if asked to filter an empty array', function() {\n    eq(R.reject(function(x) { return x > 100; }, []), []);\n  });\n  it('filters objects', function() {\n    eq(R.reject(R.equals(0), {}), {});\n    eq(R.reject(R.equals(0), {x: 0, y: 0, z: 0}), {});\n    eq(R.reject(R.equals(0), {x: 1, y: 0, z: 0}), {x: 1});\n    eq(R.reject(R.equals(0), {x: 1, y: 2, z: 0}), {x: 1, y: 2});\n    eq(R.reject(R.equals(0), {x: 1, y: 2, z: 3}), {x: 1, y: 2, z: 3});\n  });\n  it('dispatches to `filter` method', function() {\n    function Nothing() {}\n    Nothing.value = new Nothing();\n    Nothing.prototype.filter = function() {\n      return this;\n    };\n    function Just(x) { this.value = x; }\n    Just.prototype.filter = function(pred) {\n      return pred(this.value) ? this : Nothing.value;\n    };\n    var m = new Just(42);\n    eq(R.filter(R.T, m), m);\n    eq(R.filter(R.F, m), Nothing.value);\n    eq(R.reject(R.T, m), Nothing.value);\n    eq(R.reject(R.F, m), m);\n  });"},"repeat":{"method":"repeat","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('repeat', function() {\n  it('returns a lazy list of identical values', function() {\n    eq(R.repeat(0, 5), [0, 0, 0, 0, 0]);\n  });\n  it('can accept any value, including `null`', function() {\n    eq(R.repeat(null, 3), [null, null, null]);\n  });"},"replace":{"method":"replace","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('replace', function() {\n  it('replaces substrings of the input string', function() {\n    eq(R.replace('1', 'one', '1 two three'), 'one two three');\n  });\n  it('replaces regex matches of the input string', function() {\n    eq(R.replace(/\\d+/g, 'num', '1 2 three'), 'num num three');\n  });"},"reverse":{"method":"reverse","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\n\ndescribe('reverse', function() {\n  it('reverses arrays', function() {\n    eq(R.reverse([]), []);\n    eq(R.reverse([1]), [1]);\n    eq(R.reverse([1, 2]), [2, 1]);\n    eq(R.reverse([1, 2, 3]), [3, 2, 1]);\n  });\n  it('reverses twice an array should be the array itself', function() {\n    fc.assert(fc.property(fc.array(fc.anything()), function(array) {\n      eq(R.reverse(R.reverse(array)), array);\n    }));\n  });\n  it('reverses strings', function() {\n    eq(R.reverse(''), '');\n    eq(R.reverse('a'), 'a');\n    eq(R.reverse('ab'), 'ba');\n    eq(R.reverse('abc'), 'cba');\n  });\n  it('reverses twice a string should be the string itself', function() {\n    fc.assert(fc.property(fc.fullUnicodeString(), function(str) {\n      eq(R.reverse(R.reverse(str)), str);\n    }));\n  });"},"slice":{"method":"slice","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('slice', function() {\n  it('retrieves the proper sublist of a list', function() {\n    var list = [8, 6, 7, 5, 3, 0, 9];\n    eq(R.slice(2, 5, list), [7, 5, 3]);\n  });\n  it('handles array-like object', function() {\n    var args = (function() { return arguments; }(1, 2, 3, 4, 5));\n    eq(R.slice(1, 4, args), [2, 3, 4]);\n  });\n  it('can operate on strings', function() {\n    eq(R.slice(0, 0, 'abc'), '');\n    eq(R.slice(0, 1, 'abc'), 'a');\n    eq(R.slice(0, 2, 'abc'), 'ab');\n    eq(R.slice(0, 3, 'abc'), 'abc');\n    eq(R.slice(0, 4, 'abc'), 'abc');\n    eq(R.slice(1, 0, 'abc'), '');\n    eq(R.slice(1, 1, 'abc'), '');\n    eq(R.slice(1, 2, 'abc'), 'b');\n    eq(R.slice(1, 3, 'abc'), 'bc');\n    eq(R.slice(1, 4, 'abc'), 'bc');\n    eq(R.slice(0, -4, 'abc'), '');\n    eq(R.slice(0, -3, 'abc'), '');\n    eq(R.slice(0, -2, 'abc'), 'a');\n    eq(R.slice(0, -1, 'abc'), 'ab');\n    eq(R.slice(0, -0, 'abc'), '');\n    eq(R.slice(-2, -4, 'abc'), '');\n    eq(R.slice(-2, -3, 'abc'), '');\n    eq(R.slice(-2, -2, 'abc'), '');\n    eq(R.slice(-2, -1, 'abc'), 'b');\n    eq(R.slice(-2, -0, 'abc'), '');\n  });"},"sort":{"method":"sort","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('sort', function() {\n  it('sorts the elements of a list', function() {\n    eq(R.sort(function(a, b) {return a - b;}, [3, 1, 8, 1, 2, 5]), [1, 1, 2, 3, 5, 8]);\n  });\n  it('does not affect the list passed supplied', function() {\n    var list = [3, 1, 8, 1, 2, 5];\n    eq(R.sort(function(a, b) {return a - b;}, list), [1, 1, 2, 3, 5, 8]);\n    eq(list, [3, 1, 8, 1, 2, 5]);\n  });"},"sortBy":{"diffReason":"Ramda method works with array-like objects","method":"sortBy","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\nvar albums = [\n  {title: 'Art of the Fugue', artist: 'Glenn Gould', genre: 'Baroque'},\n  {title: 'A Farewell to Kings', artist: 'Rush', genre: 'Rock'},\n  {title: 'Timeout', artist: 'Dave Brubeck Quartet', genre: 'Jazz'},\n  {title: 'Fly By Night', artist: 'Rush', genre: 'Rock'},\n  {title: 'Goldberg Variations', artist: 'Daniel Barenboim', genre: 'Baroque'},\n  {title: 'New World Symphony', artist: 'Leonard Bernstein', genre: 'Romantic'},\n  {title: 'Romance with the Unseen', artist: 'Don Byron', genre: 'Jazz'},\n  {title: 'Somewhere In Time', artist: 'Iron Maiden', genre: 'Metal'},\n  {title: 'In Times of Desparation', artist: 'Danny Holt', genre: 'Modern'},\n  {title: 'Evita', artist: 'Various', genre: 'Broadway'},\n  {title: 'Five Leaves Left', artist: 'Nick Drake', genre: 'Folk'},\n  {title: 'The Magic Flute', artist: 'John Eliot Gardiner', genre: 'Classical'}\n];\ndescribe('sortBy', function() {\n  it('sorts by a simple property of the objects', function() {\n    var sortedAlbums = R.sortBy(R.prop('title'), albums);\n    eq(sortedAlbums.length, albums.length);\n    eq(sortedAlbums[0].title, 'A Farewell to Kings');\n    eq(sortedAlbums[11].title, 'Timeout');\n  });\n  it('preserves object identity', function() {\n    var a = {value: 'a'};\n    var b = {value: 'b'};\n    var result = R.sortBy(R.prop('value'), [b, a]);\n    eq(result[0], a);\n    eq(result[1], b);\n  });\n  it('sorts array-like object', function() {\n    var args = (function() { return arguments; }('c', 'a', 'b'));\n    var result = R.sortBy(R.identity, args);\n    eq(result[0], 'a');\n    eq(result[1], 'b');\n    eq(result[2], 'c');\n  });"},"split":{"method":"split","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('split', function() {\n  it('splits a string into an array', function() {\n    eq(R.split('.', 'a.b.c.xyz.d'), ['a', 'b', 'c', 'xyz', 'd']);\n  });\n  it('the split string can be arbitrary', function() {\n    eq(R.split('at', 'The Cat in the Hat sat on the mat'), ['The C', ' in the H', ' s', ' on the m', '']);\n  });"},"splitAt":{"method":"splitAt","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('splitAt', function() {\n  it('splits an array at a given index', function() {\n    eq(R.splitAt(1, [1, 2, 3]), [[1], [2, 3]]);\n  });\n  it('splits a string at a given index', function() {\n    eq(R.splitAt(5, 'hello world'), ['hello', ' world']);\n  });\n  it('can handle index greater than array length', function() {\n    eq(R.splitAt(4, [1, 2]), [[1, 2], []]);\n  });\n  it('can support negative index', function() {\n    eq(R.splitAt(-1, 'foobar'), ['fooba', 'r']);\n  });"},"splitEvery":{"method":"splitEvery","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('splitEvery', function() {\n  it('splits a collection into slices of the specified length', function() {\n    eq(R.splitEvery(1, [1, 2, 3, 4]), [[1], [2], [3], [4]]);\n    eq(R.splitEvery(2, [1, 2, 3, 4]), [[1, 2], [3, 4]]);\n    eq(R.splitEvery(3, [1, 2, 3, 4]), [[1, 2, 3], [4]]);\n    eq(R.splitEvery(4, [1, 2, 3, 4]), [[1, 2, 3, 4]]);\n    eq(R.splitEvery(5, [1, 2, 3, 4]), [[1, 2, 3, 4]]);\n    eq(R.splitEvery(3, []), []);\n    eq(R.splitEvery(1, 'abcd'), ['a', 'b', 'c', 'd']);\n    eq(R.splitEvery(2, 'abcd'), ['ab', 'cd']);\n    eq(R.splitEvery(3, 'abcd'), ['abc', 'd']);\n    eq(R.splitEvery(4, 'abcd'), ['abcd']);\n    eq(R.splitEvery(5, 'abcd'), ['abcd']);\n    eq(R.splitEvery(3, ''), []);\n  });\n  it('throws if first argument is not positive', function() {\n    var test = function(err) {\n      return err.constructor === Error &&\n             err.message === 'First argument to splitEvery must be a positive integer';\n    };\n    assert.throws(function() { R.splitEvery(0, []); }, test);\n    assert.throws(function() { R.splitEvery(0, ''); }, test);\n    assert.throws(function() { R.splitEvery(-1, []); }, test);\n    assert.throws(function() { R.splitEvery(-1, ''); }, test);\n  });"},"splitWhen":{"method":"splitWhen","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('splitWhen', function() {\n  it('splits an array at the first instance to satisfy the predicate', function() {\n    eq(R.splitWhen(R.equals(2), [1, 2, 3]), [[1], [2, 3]]);\n  });\n  it('retains all original elements', function() {\n    eq(R.splitWhen(R.T, [1, 1, 1]), [[], [1, 1, 1]]);\n  });\n  it('only splits once', function() {\n    eq(R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]), [[1], [2, 3, 1, 2, 3]]);\n  });"},"startsWith":{"method":"startsWith","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('startsWith', function() {\n  it('should return true when a string starts with the provided value', function() {\n    eq(R.startsWith('a', 'abc'), true);\n  });\n  it('should return true when a long string starts with the provided value', function() {\n    eq(R.startsWith('astro', 'astrology'), true);\n  });\n  it('should return false when a string does not start with the provided value', function() {\n    eq(R.startsWith('b', 'abc'), false);\n  });\n  it('should return false when a long string does not start with the provided value', function() {\n    eq(R.startsWith('stro', 'astrology'), false);\n  });\n  it('should return true when an array starts with the provided value', function() {\n    eq(R.startsWith(['a'], ['a', 'b', 'c']), true);\n  });\n  it('should return true when an array starts with the provided values', function() {\n    eq(R.startsWith(['a', 'b'], ['a', 'b', 'c']), true);\n  });\n  it('should return false when an array does not start with the provided value', function() {\n    eq(R.startsWith(['b'], ['a', 'b', 'c']), false);\n  });\n  it('should return false when an array does not start with the provided values', function() {\n    eq(R.startsWith(['b', 'c'], ['a', 'b', 'c']), false);\n  });"},"subtract":{"method":"subtract","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('subtract', function() {\n  it('subtracts two numbers', function() {\n    eq(R.subtract(22, 7), 15);\n  });\n  it('coerces its arguments to numbers', function() {\n    eq(R.subtract('1', '2'), -1);\n    eq(R.subtract(1, '2'), -1);\n    eq(R.subtract(true, false), 1);\n    eq(R.subtract(null, null), 0);\n    eq(R.subtract(undefined, undefined), NaN);\n    eq(R.subtract(new Date(1), new Date(2)), -1);\n  });"},"sum":{"method":"sum","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('sum', function() {\n  it('adds together the array of numbers supplied', function() {\n    eq(R.sum([1, 2, 3, 4]), 10);\n  });\n  it('does not save the state of the accumulator', function() {\n    eq(R.sum([1, 2, 3, 4]), 10);\n    eq(R.sum([1]), 1);\n    eq(R.sum([5, 5, 5, 5, 5]), 25);\n  });"},"symmetricDifference":{"method":"symmetricDifference","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar fc = require('fast-check');\n\ndescribe('symmetricDifference', function() {\n  var M = [1, 2, 3, 4];\n  var M2 = [1, 2, 3, 4, 1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  var N2 = [3, 3, 4, 4, 5, 5, 6, 6];\n  var Z = [3, 4, 5, 6, 10];\n  var Z2 = [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8];\n  it('finds the set of all elements in the first or second list but not both', function() {\n    eq(R.symmetricDifference(M, N), [1, 2, 5, 6]);\n  });\n  it('does not allow duplicates in the output even if the input lists had duplicates', function() {\n    eq(R.symmetricDifference(M2, N2), [1, 2, 5, 6]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.symmetricDifference([0], [-0]).length, 2);\n    eq(R.symmetricDifference([-0], [0]).length, 2);\n    eq(R.symmetricDifference([NaN], [NaN]).length, 0);\n    eq(R.symmetricDifference([new Just([42])], [new Just([42])]).length, 0);\n  });\n  it('works for arrays of different lengths', function() {\n    eq(R.symmetricDifference(Z, Z2), [10, 1, 2, 7, 8]);\n    eq(R.symmetricDifference(Z2, Z), [1, 2, 7, 8, 10]);\n  });\n  it('will not create a \"sparse\" array', function() {\n    eq(R.symmetricDifference(M2, [3]).length, 3);\n  });\n  it('returns an empty array if there are no different elements', function() {\n    eq(R.symmetricDifference(M2, M), []);\n    eq(R.symmetricDifference(M, M2), []);\n  });\n  // Arbitrary producing arrays of unique values (with respect to R.equals)\n  var compatibleREquals = fc.array(fc.anything({\n    maxDepth: 0,\n    withBoxedValues: true,\n    withNullPrototype: true,\n    withObjectString: true\n  })).map(array => R.uniq(array));\n  it('returns empty arrays when receiving twice the same array', function() {\n    fc.assert(fc.property(fc.clone(compatibleREquals, 2), function(arrays) {\n      var A1 = arrays[0];\n      var A2 = arrays[1];\n      eq(R.symmetricDifference(A1, A2), []);\n    }));\n  });\n  it('returns empty arrays when receiving an array and a permutation of it', function() {\n    fc.assert(fc.property(fc.clone(compatibleREquals, 2).chain(function(arrays) {\n      return fc.tuple(fc.constant(arrays[0]), fc.shuffledSubarray(arrays[1], arrays[1].length, arrays[1].length));\n    }), function(arrays) {\n      var A1 = arrays[0];\n      var A2 = arrays[1];\n      eq(R.symmetricDifference(A1, A2), []);\n    }));\n  });\n  it('returns missing items when receiving an array and a permuted subset of it', function() {\n    fc.assert(fc.property(fc.clone(compatibleREquals, 2).chain(function(arrays) {\n      return fc.tuple(fc.constant(arrays[0]), fc.shuffledSubarray(arrays[1]));\n    }), function(arrays) {\n      var A1 = arrays[0];\n      var A2 = arrays[1];\n      eq(R.symmetricDifference(A1, A2).length, A1.length - A2.length);\n    }));\n  });\n  it('returns an array not containing too many items', function() {\n    fc.assert(fc.property(compatibleREquals, compatibleREquals, compatibleREquals, compatibleREquals, compatibleREquals, function(A1, A2, B, C1, C2) {\n      var M = R.uniq(A1.concat(B).concat(C1));\n      var N = R.uniq(A2.concat(B).concat(C2));\n      var difference = R.symmetricDifference(M, N);\n      var upperBoundDifferenceLength = A1.length + A2.length + C1.length + C2.length;\n      eq(difference.length <= upperBoundDifferenceLength, true);\n    }));\n  });\n  it('returns an array containing only items coming from one of the sources', function() {\n    fc.assert(fc.property(compatibleREquals, compatibleREquals, compatibleREquals, compatibleREquals, compatibleREquals, function(A1, A2, B, C1, C2) {\n      var M = R.uniq(A1.concat(B).concat(C1));\n      var N = R.uniq(A2.concat(B).concat(C2));\n      var MN = R.uniq(M.concat(N));\n      var difference = R.symmetricDifference(M, N);\n      eq(R.symmetricDifference(difference, MN).length, MN.length - difference.length);\n    }));\n  });\n});"},"tail":{"method":"tail","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('tail', function() {\n  it('returns the tail of an ordered collection', function() {\n    eq(R.tail([1, 2, 3]), [2, 3]);\n    eq(R.tail([2, 3]), [3]);\n    eq(R.tail([3]), []);\n    eq(R.tail([]), []);\n    eq(R.tail('abc'), 'bc');\n    eq(R.tail('bc'), 'c');\n    eq(R.tail('c'), '');\n    eq(R.tail(''), '');\n  });\n  it('throws if applied to null or undefined', function() {\n    assert.throws(function() { R.tail(null); }, TypeError);\n    assert.throws(function() { R.tail(undefined); }, TypeError);\n  });"},"take":{"diffReason":"Rambda library doesn't have 'R.into` method","method":"take","content":"var assert = require('assert');\nvar sinon = require('sinon');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('take', function() {\n  it('takes only the first `n` elements from a list', function() {\n    eq(R.take(3, ['a', 'b', 'c', 'd', 'e', 'f', 'g']), ['a', 'b', 'c']);\n  });\n  it('returns only as many as the array can provide', function() {\n    eq(R.take(3, [1, 2]), [1, 2]);\n    eq(R.take(3, []), []);\n  });\n  it('returns an equivalent list if `n` is < 0', function() {\n    eq(R.take(-1, [1, 2, 3]), [1, 2, 3]);\n    eq(R.take(-Infinity, [1, 2, 3]), [1, 2, 3]);\n  });\n  it('never returns the input array', function() {\n    var xs = [1, 2, 3];\n    assert.notStrictEqual(R.take(3, xs), xs);\n    assert.notStrictEqual(R.take(Infinity, xs), xs);\n    assert.notStrictEqual(R.take(-1, xs), xs);\n  });\n  it('can operate on strings', function() {\n    eq(R.take(3, 'Ramda'), 'Ram');\n    eq(R.take(2, 'Ramda'), 'Ra');\n    eq(R.take(1, 'Ramda'), 'R');\n    eq(R.take(0, 'Ramda'), '');\n  });\n  it('handles zero correctly (#1224)', function() {\n    eq(R.into([], R.take(0), [1, 2, 3]), []);\n  });\n  it('steps correct number of times', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(2)), [1, 2, 3]);\n    sinon.assert.calledTwice(spy);\n  });\n  it('transducer called for every member of list if `n` is < 0', function() {\n    var spy = sinon.spy();\n    R.into([], R.compose(R.map(spy), R.take(-1)), [1, 2, 3]);\n    sinon.assert.calledThrice(spy);\n  });"},"takeLast":{"method":"takeLast","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('takeLast', function() {\n  it('takes only the last `n` elements from a list', function() {\n    eq(R.takeLast(3, ['a', 'b', 'c', 'd', 'e', 'f', 'g']), ['e', 'f', 'g']);\n  });\n  it('returns only as many as the array can provide', function() {\n    eq(R.takeLast(3, [1, 2]), [1, 2]);\n    eq(R.takeLast(3, []), []);\n  });\n  it('returns an equivalent list if `n` is < 0', function() {\n    eq(R.takeLast(-1, [1, 2, 3]), [1, 2, 3]);\n    eq(R.takeLast(-Infinity, [1, 2, 3]), [1, 2, 3]);\n  });\n  it('never returns the input array', function() {\n    var xs = [1, 2, 3];\n    assert.notStrictEqual(R.takeLast(3, xs), xs);\n    assert.notStrictEqual(R.takeLast(Infinity, xs), xs);\n    assert.notStrictEqual(R.takeLast(-1, xs), xs);\n  });\n  it('can operate on strings', function() {\n    eq(R.takeLast(3, 'Ramda'), 'mda');\n  });\n  it('handles zero correctly (#1224)', function() {\n    eq(R.takeLast(0, [1, 2, 3]), []);\n  });"},"takeLastWhile":{"method":"takeLastWhile","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('takeLastWhile', function() {\n  it('continues taking elements while the function reports `true`', function() {\n    eq(R.takeLastWhile(function(x) {return x !== 5;}, [1, 3, 5, 7, 9]), [7, 9]);\n  });\n  it('starts at the right arg and acknowledges undefined', function() {\n    eq(R.takeLastWhile(function() { assert(false); }, []), []);\n    eq(R.takeLastWhile(function(x) {return x !== void 0;}, [1, 3, void 0, 5, 7]), [5, 7]);\n  });\n  it('can operate on strings', function() {\n    eq(R.takeLastWhile(function(x) { return x !== 'R'; }, 'Ramda'), 'amda');\n  });"},"takeWhile":{"diffReason":"Ramda method works with strings not only arrays","method":"takeWhile","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('takeWhile', function() {\n  it('continues taking elements while the function reports `true`', function() {\n    eq(R.takeWhile(function(x) {return x !== 5;}, [1, 3, 5, 7, 9]), [1, 3]);\n  });\n  it('starts at the right arg and acknowledges undefined', function() {\n    eq(R.takeWhile(function() { assert(false); }, []), []);\n    eq(R.takeWhile(function(x) {return x !== void 0;}, [1, 3, void 0, 5, 7]), [1, 3]);\n  });\n  it('can operate on strings', function() {\n    eq(R.takeWhile(function(x) { return x !== 'd'; }, 'Ramda'), 'Ram');\n  });"},"tap":{"diffReason":"Ramda method can act as a transducer","method":"tap","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar listXf = require('./helpers/listXf');\nvar _curry2 = require('rambda/internal/_curry2');\n\ndescribe('tap', function() {\n  var pushToList = _curry2(function(lst, x) { lst.push(x); });\n  it('returns a function that always returns its argument', function() {\n    var f = R.tap(R.identity);\n    eq(typeof f, 'function');\n    eq(f(100), 100);\n    eq(f(undefined), undefined);\n    eq(f(null), null);\n  });\n  it(\"may take a function as the first argument that executes with tap's argument\", function() {\n    var sideEffect = 0;\n    eq(sideEffect, 0);\n    var rv = R.tap(function(x) { sideEffect = 'string ' + x; }, 200);\n    eq(rv, 200);\n    eq(sideEffect, 'string 200');\n  });\n  it('can act as a transducer', function() {\n    var sideEffect = [];\n    var numbers = [1,2,3,4,5];\n    var xf = R.compose(R.map(R.identity), R.tap(pushToList(sideEffect)));\n    eq(R.into([], xf, numbers), numbers);\n    eq(sideEffect, numbers);\n  });\n  it('dispatches to transformer objects', function() {\n    var sideEffect = [];\n    var pushToSideEffect = pushToList(sideEffect);\n    eq(R.tap(pushToSideEffect, listXf), {\n      f: pushToSideEffect,\n      xf: listXf\n    });\n  });"},"test":{"method":"test","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('test', function() {\n  it('returns true if string matches pattern', function() {\n    eq(R.test(/^x/, 'xyz'), true);\n  });\n  it('returns false if string does not match pattern', function() {\n    eq(R.test(/^y/, 'xyz'), false);\n  });\n  it('is referentially transparent', function() {\n    var pattern = /x/g;\n    eq(pattern.lastIndex, 0);\n    eq(R.test(pattern, 'xyz'), true);\n    eq(pattern.lastIndex, 0);\n    eq(R.test(pattern, 'xyz'), true);\n  });\n  it('throws if first argument is not a regexp', function() {\n    assert.throws(\n      function() { R.test('foo', 'bar'); },\n      function(err) {\n        return err.constructor === TypeError &&\n               err.message === '‘test’ requires a value of type RegExp ' +\n                               'as its first argument; received \"foo\"';\n      }\n    );\n  });"},"times":{"method":"times","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\ndescribe('times', function() {\n  it('takes a map func', function() {\n    eq(R.times(R.identity, 5), [0, 1, 2, 3, 4]);\n    eq(R.times(function(x) {\n      return x * 2;\n    }, 5), [0, 2, 4, 6, 8]);\n  });\n  it('throws if second argument is not a valid array length', function() {\n    assert.throws(function() { R.times(3)('cheers!'); }, RangeError);\n    assert.throws(function() { R.times(R.identity, -1); }, RangeError);\n  });"},"toLower":{"method":"toLower","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('toLower', function() {\n  it('returns the lower-case equivalent of the input string', function() {\n    eq(R.toLower('XYZ'), 'xyz');\n  });"},"toPairs":{"method":"toPairs","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('toPairs', function() {\n  it('converts an object into an array of two-element [key, value] arrays', function() {\n    eq(R.toPairs({a: 1, b: 2, c: 3}), [['a', 1], ['b', 2], ['c', 3]]);\n  });\n  it(\"only iterates the object's own properties\", function() {\n    var F = function() {\n      this.x = 1;\n      this.y = 2;\n    };\n    F.prototype.protoProp = 'you can\\'t see me';\n    var f = new F();\n    eq(R.toPairs(f), [['x', 1], ['y', 2]]);\n  });"},"toString":{"method":"toString","content":"var assert = require('assert');\n\nvar R = require('../../../../../rambda/dist/rambda');\ndescribe('toString', function() {\n  it('returns the string representation of null', function() {\n    assert.strictEqual(R.toString(null), 'null');\n  });\n  it('returns the string representation of undefined', function() {\n    assert.strictEqual(R.toString(undefined), 'undefined');\n  });\n  it('returns the string representation of a Boolean primitive', function() {\n    assert.strictEqual(R.toString(true), 'true');\n    assert.strictEqual(R.toString(false), 'false');\n  });\n  it('returns the string representation of a number primitive', function() {\n    assert.strictEqual(R.toString(0), '0');\n    assert.strictEqual(R.toString(-0), '-0');\n    assert.strictEqual(R.toString(1.23), '1.23');\n    assert.strictEqual(R.toString(-1.23), '-1.23');\n    assert.strictEqual(R.toString(1e+23), '1e+23');\n    assert.strictEqual(R.toString(-1e+23), '-1e+23');\n    assert.strictEqual(R.toString(1e-23), '1e-23');\n    assert.strictEqual(R.toString(-1e-23), '-1e-23');\n    assert.strictEqual(R.toString(Infinity), 'Infinity');\n    assert.strictEqual(R.toString(-Infinity), '-Infinity');\n    assert.strictEqual(R.toString(NaN), 'NaN');\n  });\n  it('returns the string representation of a string primitive', function() {\n    assert.strictEqual(R.toString('abc'), '\"abc\"');\n    assert.strictEqual(R.toString('x \"y\" z'), '\"x \\\\\"y\\\\\" z\"');\n    assert.strictEqual(R.toString(\"' '\"), '\"\\' \\'\"');\n    assert.strictEqual(R.toString('\" \"'), '\"\\\\\" \\\\\"\"');\n    assert.strictEqual(R.toString('\\b \\b'), '\"\\\\b \\\\b\"');\n    assert.strictEqual(R.toString('\\f \\f'), '\"\\\\f \\\\f\"');\n    assert.strictEqual(R.toString('\\n \\n'), '\"\\\\n \\\\n\"');\n    assert.strictEqual(R.toString('\\r \\r'), '\"\\\\r \\\\r\"');\n    assert.strictEqual(R.toString('\\t \\t'), '\"\\\\t \\\\t\"');\n    assert.strictEqual(R.toString('\\v \\v'), '\"\\\\v \\\\v\"');\n    assert.strictEqual(R.toString('\\0 \\0'), '\"\\\\0 \\\\0\"');\n    assert.strictEqual(R.toString('\\\\ \\\\'), '\"\\\\\\\\ \\\\\\\\\"');\n  });\n  it('returns the string representation of a Boolean object', function() {\n    assert.strictEqual(R.toString(new Boolean(true)), 'new Boolean(true)');\n    assert.strictEqual(R.toString(new Boolean(false)), 'new Boolean(false)');\n  });\n  it('returns the string representation of a Number object', function() {\n    assert.strictEqual(R.toString(new Number(0)), 'new Number(0)');\n    assert.strictEqual(R.toString(new Number(-0)), 'new Number(-0)');\n  });\n  it('returns the string representation of a String object', function() {\n    assert.strictEqual(R.toString(new String('abc')), 'new String(\"abc\")');\n    assert.strictEqual(R.toString(new String('x \"y\" z')), 'new String(\"x \\\\\"y\\\\\" z\")');\n    assert.strictEqual(R.toString(new String(\"' '\")), 'new String(\"\\' \\'\")');\n    assert.strictEqual(R.toString(new String('\" \"')), 'new String(\"\\\\\" \\\\\"\")');\n    assert.strictEqual(R.toString(new String('\\b \\b')), 'new String(\"\\\\b \\\\b\")');\n    assert.strictEqual(R.toString(new String('\\f \\f')), 'new String(\"\\\\f \\\\f\")');\n    assert.strictEqual(R.toString(new String('\\n \\n')), 'new String(\"\\\\n \\\\n\")');\n    assert.strictEqual(R.toString(new String('\\r \\r')), 'new String(\"\\\\r \\\\r\")');\n    assert.strictEqual(R.toString(new String('\\t \\t')), 'new String(\"\\\\t \\\\t\")');\n    assert.strictEqual(R.toString(new String('\\v \\v')), 'new String(\"\\\\v \\\\v\")');\n    assert.strictEqual(R.toString(new String('\\0 \\0')), 'new String(\"\\\\0 \\\\0\")');\n    assert.strictEqual(R.toString(new String('\\\\ \\\\')), 'new String(\"\\\\\\\\ \\\\\\\\\")');\n  });\n  it('returns the string representation of a Date object', function() {\n    assert.strictEqual(R.toString(new Date('2001-02-03T04:05:06.000Z')), 'new Date(\"2001-02-03T04:05:06.000Z\")');\n    assert.strictEqual(R.toString(new Date('XXX')), 'new Date(NaN)');\n  });\n  it('returns the string representation of a RegExp object', function() {\n    assert.strictEqual(R.toString(/(?:)/), '/(?:)/');\n    assert.strictEqual(R.toString(/\\//g), '/\\\\//g');\n  });\n  it('returns the string representation of a function', function() {\n    var add = function add(a, b) { return a + b; };\n    assert.strictEqual(R.toString(add), add.toString());\n  });\n  it('returns the string representation of an array', function() {\n    assert.strictEqual(R.toString([]), '[]');\n    assert.strictEqual(R.toString([1, 2, 3]), '[1, 2, 3]');\n    assert.strictEqual(R.toString([1, [2, [3]]]), '[1, [2, [3]]]');\n    assert.strictEqual(R.toString(['x', 'y']), '[\"x\", \"y\"]');\n  });\n  it('returns the string representation of an array with non-numeric property names', function() {\n    var xs = [1, 2, 3];\n    xs.foo = 0;\n    xs.bar = 0;\n    xs.baz = 0;\n    assert.strictEqual(R.toString(xs), '[1, 2, 3, \"bar\": 0, \"baz\": 0, \"foo\": 0]');\n  });\n  it('returns the string representation of an arguments object', function() {\n    assert.strictEqual(R.toString((function() { return arguments; })()), '(function() { return arguments; }())');\n    assert.strictEqual(R.toString((function() { return arguments; })(1, 2, 3)), '(function() { return arguments; }(1, 2, 3))');\n    assert.strictEqual(R.toString((function() { return arguments; })(['x', 'y'])), '(function() { return arguments; }([\"x\", \"y\"]))');\n  });\n  it('returns the string representation of a plain object', function() {\n    assert.strictEqual(R.toString({}), '{}');\n    assert.strictEqual(R.toString({foo: 1, bar: 2, baz: 3}), '{\"bar\": 2, \"baz\": 3, \"foo\": 1}');\n    assert.strictEqual(R.toString({'\"quoted\"': true}), '{\"\\\\\"quoted\\\\\"\": true}');\n    assert.strictEqual(R.toString({a: {b: {c: {}}}}), '{\"a\": {\"b\": {\"c\": {}}}}');\n  });\n  it('treats instance without custom `toString` method as plain object', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    assert.strictEqual(R.toString(new Point(1, 2)), '{\"x\": 1, \"y\": 2}');\n  });\n  it('dispatches to custom `toString` method', function() {\n    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    Point.prototype.toString = function() {\n      return 'new Point(' + this.x + ', ' + this.y + ')';\n    };\n    assert.strictEqual(R.toString(new Point(1, 2)), 'new Point(1, 2)');\n    function Just(x) {\n      if (!(this instanceof Just)) {\n        return new Just(x);\n      }\n      this.value = x;\n    }\n    Just.prototype.toString = function() {\n      return 'Just(' + R.toString(this.value) + ')';\n    };\n    assert.strictEqual(R.toString(Just(42)), 'Just(42)');\n    assert.strictEqual(R.toString(Just([1, 2, 3])), 'Just([1, 2, 3])');\n    assert.strictEqual(R.toString(Just(Just(Just('')))), 'Just(Just(Just(\"\")))');\n    assert.strictEqual(R.toString({toString: R.always('x')}), 'x');\n  });\n  it('handles object with no `toString` method', function() {\n    if (typeof Object.create === 'function') {\n      var a = Object.create(null);\n      var b = Object.create(null); b.x = 1; b.y = 2;\n      assert.strictEqual(R.toString(a), '{}');\n      assert.strictEqual(R.toString(b), '{\"x\": 1, \"y\": 2}');\n    }\n  });\n  it('handles circular references', function() {\n    var a = [];\n    a[0] = a;\n    assert.strictEqual(R.toString(a), '[<Circular>]');\n    var o = {};\n    o.o = o;\n    assert.strictEqual(R.toString(o), '{\"o\": <Circular>}');\n    var b = ['bee'];\n    var c = ['see'];\n    b[1] = c;\n    c[1] = b;\n    assert.strictEqual(R.toString(b), '[\"bee\", [\"see\", <Circular>]]');\n    assert.strictEqual(R.toString(c), '[\"see\", [\"bee\", <Circular>]]');\n    var p = {};\n    var q = {};\n    p.q = q;\n    q.p = p;\n    assert.strictEqual(R.toString(p), '{\"q\": {\"p\": <Circular>}}');\n    assert.strictEqual(R.toString(q), '{\"p\": {\"q\": <Circular>}}');\n    var x = [];\n    var y = {};\n    x[0] = y;\n    y.x = x;\n    assert.strictEqual(R.toString(x), '[{\"x\": <Circular>}]');\n    assert.strictEqual(R.toString(y), '{\"x\": [<Circular>]}');\n  });\n});"},"toUpper":{"method":"toUpper","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('toUpper', function() {\n  it('returns the upper-case equivalent of the input string', function() {\n    eq(R.toUpper('abc'), 'ABC');\n  });"},"transpose":{"method":"transpose","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('transpose', function() {\n  it('returns an array of two arrays', function() {\n    var input = [['a', 1], ['b', 2], ['c', 3]];\n    eq(R.transpose(input), [['a', 'b', 'c'], [1, 2, 3]]);\n  });\n  it('skips elements when rows are shorter', function() {\n    var actual = R.transpose([[10, 11], [20], [], [30, 31, 32]]);\n    var expected = [[10, 20, 30], [11, 31], [32]];\n    eq(actual, expected);\n  });\n  it('copes with empty arrays', function() {\n    eq(R.transpose([]), []);\n  });\n  it('copes with true, false, null & undefined elements of arrays', function() {\n    var actual = R.transpose([[true, false, undefined, null], [null, undefined, false, true]]);\n    var expected = [[true, null], [false, undefined], [undefined, false], [null, true]];\n    eq(actual, expected);\n  });"},"trim":{"diffReason":"Ramda method trims all ES5 whitespace","method":"trim","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('trim', function() {\n  var test = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFFHello, World!\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n  it('trims a string', function() {\n    eq(R.trim('   xyz  '), 'xyz');\n  });\n  it('trims all ES5 whitespace', function() {\n    eq(R.trim(test), 'Hello, World!');\n    eq(R.trim(test).length, 13);\n  });\n  it('does not trim the zero-width space', function() {\n    eq(R.trim('\\u200b'), '\\u200b');\n    eq(R.trim('\\u200b').length, 1);\n  });\n  if (typeof String.prototype.trim !== 'function') {\n    it('falls back to a shim if String.prototype.trim is not present', function() {\n      eq(R.trim('   xyz  '), 'xyz');\n      eq(R.trim(test), 'Hello, World!');\n      eq(R.trim(test).length, 13);\n      eq(R.trim('\\u200b'), '\\u200b');\n      eq(R.trim('\\u200b').length, 1);\n    });\n  }"},"tryCatch":{"diffReason":"Ramda method returns a function with the same arity","method":"tryCatch","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('tryCatch', function() {\n  function headX(ls) {\n    return ls[0].x;\n  }\n  function catcher() {\n    return 10101;\n  }\n  it('takes two functions and return a function', function() {\n    var mayThrow = R.tryCatch(headX, catcher);\n    eq(typeof mayThrow, 'function');\n  });\n  it('returns a function with the same arity as the `tryer` function', function() {\n    function a1(a) { return a; }\n    function a2(a, b) { return b; }\n    function a3(a, b, c) { return c; }\n    function a4(a, b, c, d) { return d; }\n    eq(R.tryCatch(a1, catcher).length, a1.length);\n    eq(R.tryCatch(a2, catcher).length, a2.length);\n    eq(R.tryCatch(a3, catcher).length, a3.length);\n    eq(R.tryCatch(a4, catcher).length, a4.length);\n  });\n  it('returns the value of the first function if it does not throw', function() {\n    var mayThrow = R.tryCatch(headX, catcher);\n    eq(mayThrow([{x: 10}, {x: 20}, {x: 30}]), 10);\n  });\n  it('returns the value of the second function if the first function throws', function() {\n    function throw10() {\n      throw new Error(10);\n    }\n    function eCatcher(e) {\n      return Number(e.message);\n    }\n    var mayThrow = R.tryCatch(headX, catcher);\n    eq(mayThrow([]), 10101);\n    var willThrow = R.tryCatch(throw10, eCatcher);\n    eq(willThrow([]), 10);\n    eq(willThrow([{}, {}, {}]), 10);\n  });\n  it('the second function gets passed the error object and the same arguments as the first function', function() {\n    function thrower(a, b, c) {\n      void c;\n      throw new Error('throwerError');\n    }\n    function catch3(e, a, b, c) {\n      return [e.message, a, b, c].join(' ');\n    }\n    var mayThrow = R.tryCatch(thrower, catch3);\n    eq(mayThrow('A', 'B', 'C'), 'throwerError A B C');\n  });"},"type":{"diffReason":"Ramda method returns 'Number' type to NaN input, while Rambda method returns 'NaN'","method":"type","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('type', function() {\n  it('\"Array\" if given an array literal', function() {\n    eq(R.type([1, 2, 3]), 'Array');\n  });\n  // it('\"Arguments\" if given an arguments object', function() {\n  //   var args = (function() { return arguments; }());\n  //   eq(R.type(args), 'Arguments');\n  // });\n  it('\"Object\" if given an object literal', function() {\n    eq(R.type({batman: 'na na na na na na na'}), 'Object');\n  });\n  it('\"RegExp\" if given a RegExp literal', function() {\n    eq(R.type(/[A-z]/), 'RegExp');\n  });\n  it('\"Number\" if given a numeric value', function() {\n    eq(R.type(4), 'Number');\n  });\n  it('\"Number\" if given the NaN value', function() {\n    eq(R.type(NaN), 'Number');\n  });\n  it('\"String\" if given a String literal', function() {\n    eq(R.type('Gooooodd Mornning Ramda!!'), 'String');\n  });\n  it('\"String\" if given a String object', function() {\n    eq(R.type(new String('I am a String object')), 'String');\n  });\n  it('\"Null\" if given the null value', function() {\n    eq(R.type(null), 'Null');\n  });\n  it('\"Undefined\" if given the undefined value', function() {\n    eq(R.type(undefined), 'Undefined');\n  });"},"union":{"diffReason":"Ramda library supports fantasy-land","method":"union","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('union', function() {\n  var M = [1, 2, 3, 4];\n  var N = [3, 4, 5, 6];\n  it('combines two lists into the set of all their elements', function() {\n    eq(R.union(M, N), [1, 2, 3, 4, 5, 6]);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.union([0], [-0]).length, 2);\n    eq(R.union([-0], [0]).length, 2);\n    eq(R.union([NaN], [NaN]).length, 1);\n    eq(R.union([new Just([42])], [new Just([42])]).length, 1);\n  });"},"uniq":{"diffReason":"Ramda method pass to `uniq` method | Ramda method uses reference equality for functions","method":"uniq","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('uniq', function() {\n  it('returns a set from any array (i.e. purges duplicate elements)', function() {\n    var list = [1, 2, 3, 1, 2, 3, 1, 2, 3];\n    eq(R.uniq(list), [1, 2, 3]);\n  });\n  it('keeps elements from the left', function() {\n    eq(R.uniq([1, 2, 3, 4, 1]), [1, 2, 3, 4]);\n  });\n  it('returns an empty array for an empty array', function() {\n    eq(R.uniq([]), []);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.uniq([-0, -0]).length, 1);\n    eq(R.uniq([0, -0]).length, 2);\n    eq(R.uniq([NaN, NaN]).length, 1);\n    eq(R.uniq([[1], [1]]).length, 1);\n    eq(R.uniq([new Just([42]), new Just([42])]).length, 1);\n  });\n  it('handles null and undefined elements', function() {\n    eq(R.uniq([void 0, null, void 0, null]), [void 0, null]);\n  });\n  it('uses reference equality for functions', function() {\n    eq(R.uniq([R.add, R.identity, R.add, R.identity, R.add, R.identity]).length, 2);\n  });"},"uniqWith":{"method":"uniqWith","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('uniqWith', function() {\n  var objs = [\n    {x: R.T, i: 0}, {x: R.F, i: 1}, {x: R.T, i: 2}, {x: R.T, i: 3},\n    {x: R.F, i: 4}, {x: R.F, i: 5}, {x: R.T, i: 6}, {x: R.F, i: 7}\n  ];\n  var objs2 = [\n    {x: R.T, i: 0}, {x: R.F, i: 1}, {x: R.T, i: 2}, {x: R.T, i: 3},\n    {x: R.F, i: 0}, {x: R.T, i: 1}, {x: R.F, i: 2}, {x: R.F, i: 3}\n  ];\n  function eqI(x, accX) { return x.i === accX.i; }\n  it('returns a set from any array (i.e. purges duplicate elements) based on predicate', function() {\n    eq(R.uniqWith(eqI, objs), objs);\n    eq(R.uniqWith(eqI, objs2), [{x: R.T, i: 0}, {x: R.F, i: 1}, {x: R.T, i: 2}, {x: R.T, i: 3}]);\n  });\n  it('keeps elements from the left', function() {\n    eq(R.uniqWith(eqI, [{i: 1}, {i: 2}, {i: 3}, {i: 4}, {i: 1}]), [{i: 1}, {i: 2}, {i: 3}, {i: 4}]);\n  });\n  it('returns an empty array for an empty array', function() {\n    eq(R.uniqWith(eqI, []), []);\n  });"},"unless":{"diffReason":"Rambda library doesn't have `R.of`","method":"unless","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\nvar _isArrayLike = require('rambda/internal/_isArrayLike');\n\ndescribe('unless', function() {\n  it('calls the whenFalse function if the validator returns a falsy value', function() {\n    eq(R.unless(_isArrayLike, R.of)(10), [10]);\n  });\n  it('returns the argument unmodified if the validator returns a truthy value', function() {\n    eq(R.unless(_isArrayLike, R.of)([10]), [10]);\n  });\n  it('returns a curried function', function() {\n    eq(R.unless(_isArrayLike)(R.of)(10), [10]);\n    eq(R.unless(_isArrayLike)(R.of)([10]), [10]);\n  });"},"update":{"diffReason":"Ramda method accepts an array-like object","method":"update","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('update', function() {\n  it('updates the value at the given index of the supplied array', function() {\n    eq(R.update(2, 4, [0, 1, 2, 3]), [0, 1, 4, 3]);\n  });\n  it('offsets negative indexes from the end of the array', function() {\n    eq(R.update(-3, 4, [0, 1, 2, 3]), [0, 4, 2, 3]);\n  });\n  it('returns the original array if the supplied index is out of bounds', function() {\n    var list = [0, 1, 2, 3];\n    eq(R.update(4, 4, list), list);\n    eq(R.update(-5, 4, list), list);\n  });\n  it('does not mutate the original array', function() {\n    var list = [0, 1, 2, 3];\n    eq(R.update(2, 4, list), [0, 1, 4, 3]);\n    eq(list, [0, 1, 2, 3]);\n  });\n  it('curries the arguments', function() {\n    eq(R.update(2)(4)([0, 1, 2, 3]), [0, 1, 4, 3]);\n  });\n  it('accepts an array-like object', function() {\n    function args() {\n      return arguments;\n    }\n    eq(R.update(2, 4, args(0, 1, 2, 3)), [0, 1, 4, 3]);\n  });"},"values":{"method":"values","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('values', function() {\n  var obj = {a: 100, b: [1, 2, 3], c: {x: 200, y: 300}, d: 'D', e: null, f: undefined};\n  function C() { this.a = 100; this.b = 200; }\n  C.prototype.x = function() { return 'x'; };\n  C.prototype.y = 'y';\n  var cobj = new C();\n  it(\"returns an array of the given object's values\", function() {\n    var vs = R.values(obj).sort();\n    var ts = [[1, 2, 3], 100, 'D', {x: 200, y: 300}, null, undefined];\n    eq(vs.length, ts.length);\n    eq(vs[0], ts[0]);\n    eq(vs[1], ts[1]);\n    eq(vs[2], ts[2]);\n    eq(vs[3], ts[3]);\n    eq(vs[4], ts[4]);\n    eq(vs[5], ts[5]);\n    eq(R.values({\n      hasOwnProperty: false\n    }), [false]);\n  });\n  it(\"does not include the given object's prototype properties\", function() {\n    eq(R.values(cobj), [100, 200]);\n  });\n  it('returns an empty object for primitives', function() {\n    eq(R.values(null), []);\n    eq(R.values(undefined), []);\n    eq(R.values(55), []);\n    eq(R.values('foo'), []);\n    eq(R.values(true), []);\n    eq(R.values(false), []);\n    eq(R.values(NaN), []);\n    eq(R.values(Infinity), []);\n    eq(R.values([]), []);\n  });"},"when":{"method":"when","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('when', function() {\n  it('calls the whenTrue function if the validator returns a truthy value', function() {\n    eq(R.when(R.is(Number), R.add(1))(10), 11);\n  });\n  it('returns the argument unmodified if the validator returns a falsy value', function() {\n    eq(R.when(R.is(Number), R.add(1))('hello'), 'hello');\n  });\n  it('returns a curried function', function() {\n    var ifIsNumber = R.when(R.is(Number));\n    eq(ifIsNumber(R.add(1))(15), 16);\n    eq(ifIsNumber(R.add(1))('hello'), 'hello');\n  });"},"where":{"diffReason":"Ramba method looks inside `prototype` property","method":"where","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('where', function() {\n  it('returns true if the test object satisfies the spec', function() {\n    var spec = {x: R.equals(1), y: R.equals(2)};\n    var test1 = {x: 0, y: 200};\n    var test2 = {x: 0, y: 10};\n    var test3 = {x: 1, y: 101};\n    var test4 = {x: 1, y: 2};\n    eq(R.where(spec, test1), false);\n    eq(R.where(spec, test2), false);\n    eq(R.where(spec, test3), false);\n    eq(R.where(spec, test4), true);\n  });\n  it('does not need the spec and the test object to have the same interface (the test object will have a superset of the specs properties)', function() {\n    var spec = {x: R.equals(100)};\n    var test1 = {x: 20, y: 100, z: 100};\n    var test2 = {w: 1, x: 100, y: 100, z: 100};\n    eq(R.where(spec, test1), false);\n    eq(R.where(spec, test2), true);\n  });\n  it('matches specs that have undefined properties', function() {\n    var spec = {x: R.equals(undefined)};\n    var test1 = {};\n    var test2 = {x: null};\n    var test3 = {x: undefined};\n    var test4 = {x: 1};\n    eq(R.where(spec, test1), true);\n    eq(R.where(spec, test2), false);\n    eq(R.where(spec, test3), true);\n    eq(R.where(spec, test4), false);\n  });\n  it('is true for an empty spec', function() {\n    eq(R.where({}, {a: 1}), true);\n  });\n  it('matches inherited properties', function() {\n    var spec = {\n      toString: R.equals(Object.prototype.toString),\n      valueOf: R.equals(Object.prototype.valueOf)\n    };\n    eq(R.where(spec, {}), true);\n  });\n  it('does not match inherited spec', function() {\n    function Spec() { this.y = R.equals(6); }\n    Spec.prototype.x = R.equals(5);\n    var spec = new Spec();\n    eq(R.where(spec, {y: 6}), true);\n    eq(R.where(spec, {x: 5}), false);\n  });"},"whereEq":{"diffReason":"Ramba method looks inside `prototype` property | Rambda.equals doesn't support equality of functions","method":"whereEq","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('whereEq', function() {\n  it('returns true if the test object satisfies the spec', function() {\n    var spec = {x: 1, y: 2};\n    var test1 = {x: 0, y: 200};\n    var test2 = {x: 0, y: 10};\n    var test3 = {x: 1, y: 101};\n    var test4 = {x: 1, y: 2};\n    eq(R.whereEq(spec, test1), false);\n    eq(R.whereEq(spec, test2), false);\n    eq(R.whereEq(spec, test3), false);\n    eq(R.whereEq(spec, test4), true);\n  });\n  it('does not need the spec and the test object to have the same interface (the test object will have a superset of the specs properties)', function() {\n    var spec = {x: 100};\n    var test1 = {x: 20, y: 100, z: 100};\n    var test2 = {w: 1, x: 100, y: 100, z: 100};\n    eq(R.whereEq(spec, test1), false);\n    eq(R.whereEq(spec, test2), true);\n  });\n  it('matches specs that have undefined properties', function() {\n    var spec = {x: undefined};\n    var test1 = {};\n    var test2 = {x: null};\n    var test3 = {x: undefined};\n    var test4 = {x: 1};\n    eq(R.whereEq(spec, test1), true);\n    eq(R.whereEq(spec, test2), false);\n    eq(R.whereEq(spec, test3), true);\n    eq(R.whereEq(spec, test4), false);\n  });\n  it('is true for an empty spec', function() {\n    eq(R.whereEq({}, {a: 1}), true);\n  });\n  it('reports true when the object equals the spec', function() {\n    eq(R.whereEq(R, R), true);\n  });\n  function Parent() {\n    this.y = 6;\n  }\n  Parent.prototype.a = undefined;\n  Parent.prototype.x = 5;\n  var parent = new Parent();\n  it('matches inherited props', function() {\n    eq(R.whereEq({y: 6}, parent), true);\n    eq(R.whereEq({x: 5}, parent), true);\n    eq(R.whereEq({x: 5, y: 6}, parent), true);\n    eq(R.whereEq({x: 4, y: 6}, parent), false);\n  });\n  it('does not match inherited spec', function() {\n    eq(R.whereEq(parent, {y: 6}), true);\n    eq(R.whereEq(parent, {x: 5}), false);\n  });"},"without":{"diffReason":"Ramda method act as a transducer | Ramda method pass to `equals` method","method":"without","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('without', function() {\n  it('returns an array not containing values in the first argument', function() {\n    eq(R.without([1, 2], [1, 2, 1, 4, 5]), [4, 5]);\n  });\n  it('can act as a transducer', function() {\n    eq(R.into([], R.without([1]), [1]), []);\n  });\n  it('has R.equals semantics', function() {\n    function Just(x) { this.value = x; }\n    Just.prototype.equals = function(x) {\n      return x instanceof Just && R.equals(x.value, this.value);\n    };\n    eq(R.without([0], [-0]).length, 1);\n    eq(R.without([-0], [0]).length, 1);\n    eq(R.without([NaN], [NaN]).length, 0);\n    eq(R.without([[1]], [[1]]).length, 0);\n    eq(R.without([new Just([42])], [new Just([42])]).length, 0);\n  });"},"xor":{"diffReason":"Ramda method support empty call of method","method":"xor","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('xor', function() {\n  it('compares two values with exclusive or', function() {\n    eq(R.xor(true, true), false);\n    eq(R.xor(true, false), true);\n    eq(R.xor(false, true), true);\n    eq(R.xor(false, false), false);\n  });\n  it('when both values are truthy, it should return false', function() {\n    eq(R.xor(true, 'foo'), false);\n    eq(R.xor(42, true), false);\n    eq(R.xor('foo', 42), false);\n    eq(R.xor({}, true), false);\n    eq(R.xor(true, []), false);\n    eq(R.xor([], {}), false);\n    eq(R.xor(new Date(), true), false);\n    eq(R.xor(true, Infinity), false);\n    eq(R.xor(Infinity, new Date()), false);\n  });\n  it('when both values are falsy, it should return false', function() {\n    eq(R.xor(null, false), false);\n    eq(R.xor(false, undefined), false);\n    eq(R.xor(undefined, null), false);\n    eq(R.xor(0, false), false);\n    eq(R.xor(false, NaN), false);\n    eq(R.xor(NaN, 0), false);\n    eq(R.xor('', false), false);\n  });\n  it('when one argument is truthy and the other is falsy, it should return true', function() {\n    eq(R.xor('foo', null), true);\n    eq(R.xor(null, 'foo'), true);\n    eq(R.xor(undefined, 42), true);\n    eq(R.xor(42, undefined), true);\n    eq(R.xor(Infinity, NaN), true);\n    eq(R.xor(NaN, Infinity), true);\n    eq(R.xor({}, ''), true);\n    eq(R.xor('', {}), true);\n    eq(R.xor(new Date(), 0), true);\n    eq(R.xor(0, new Date()), true);\n    eq(R.xor([], null), true);\n    eq(R.xor(undefined, []), true);\n  });\n  it('returns a curried function', function() {\n    eq(R.xor()(true)(true), false);\n    eq(R.xor()(true)(false), true);\n    eq(R.xor()(false)(true), true);\n    eq(R.xor()(false)(false), false);\n  });"},"zip":{"method":"zip","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('zip', function() {\n  it('returns an array of \"tuples\"', function() {\n    var a = [1, 2, 3];\n    var b = [100, 200, 300];\n    eq(R.zip(a, b), [[1, 100], [2, 200], [3, 300]]);\n  });\n  it('returns a list as long as the shorter of the lists input', function() {\n    var a = [1, 2, 3];\n    var b = [100, 200, 300, 400];\n    var c = [10, 20];\n    eq(R.zip(a, b), [[1, 100], [2, 200], [3, 300]]);\n    eq(R.zip(a, c), [[1, 10], [2, 20]]);\n  });"},"zipObj":{"method":"zipObj","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('zipObj', function() {\n  it('combines an array of keys with an array of values into a single object', function() {\n    eq(R.zipObj(['a', 'b', 'c'], [1, 2, 3]), {a: 1, b: 2, c: 3});\n  });\n  it('ignores extra values', function() {\n    eq(R.zipObj(['a', 'b', 'c'], [1, 2, 3, 4, 5, 6, 7]), {a: 1, b: 2, c: 3});\n  });\n  it('ignores extra keys', function() {\n    eq(R.zipObj(['a', 'b', 'c', 'd', 'e', 'f'], [1, 2, 3]), {a: 1, b: 2, c: 3});\n  });\n  it('last one in wins when there are duplicate keys', function() {\n    eq(R.zipObj(['a', 'b', 'c', 'a'], [1, 2, 3, 'LAST']), {a: 'LAST', b: 2, c: 3});\n  });"},"zipWith":{"method":"zipWith","content":"var R = require('../../../../../rambda/dist/rambda');\nvar eq = require('./shared/eq');\n\ndescribe('zipWith', function() {\n  var a = [1, 2, 3];\n  var b = [100, 200, 300];\n  var c = [10, 20, 30, 40, 50, 60];\n  var add = function(a, b) { return a + b; };\n  var x = function(a, b) { return a * b; };\n  var s = function(a, b) { return a + ' cow ' + b; };\n  it('returns an array created by applying its passed-in function pair-wise on its passed in arrays', function() {\n    eq(R.zipWith(add, a, b), [101, 202, 303]);\n    eq(R.zipWith(x, a, b), [100, 400, 900]);\n    eq(R.zipWith(s, a, b), ['1 cow 100', '2 cow 200', '3 cow 300']);\n  });\n  it('returns an array whose length is equal to the shorter of its input arrays', function() {\n    eq(R.zipWith(add, a, c).length, a.length);\n  });"}}
