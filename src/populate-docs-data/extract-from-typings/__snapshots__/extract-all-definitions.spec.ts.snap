// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`happy 1`] = `
Object {
  "F": "F(): boolean;",
  "T": "T(): boolean;",
  "add": "add(a: number, b: number): number;
add(a: number): (b: number) => number;",
  "adjust": "adjust<T>(index: number, replaceFn: (x: T) => T, list: readonly T[]): readonly T[];
adjust<T>(index: number, replaceFn: (x: T) => T): (list: readonly T[]) => readonly T[];",
  "all": "all<T>(predicate: (x: T) => boolean, list: readonly T[]): boolean;
all<T>(predicate: (x: T) => boolean): (list: readonly T[]) => boolean;",
  "allPass": "allPass<T>(predicates: readonly ((x: T) => boolean)[]): (input: T) => boolean;",
  "always": "always<T>(x: T): () => T;",
  "and": "and<T, U>(x: T, y: U): T | U;
and<T>(x: T): <U>(y: U) => T | U;",
  "any": "any<T>(predicate: (x: T) => boolean, list: readonly T[]): boolean;
any<T>(predicate: (x: T) => boolean): (list: readonly T[]) => boolean;",
  "anyPass": "anyPass<T>(predicates: readonly SafePred<T>[]): SafePred<T>;",
  "append": "append<T>(x: T, list: readonly T[]): readonly T[];
append<T>(x: T): <T>(list: readonly T[]) => readonly T[];",
  "applySpec": "applySpec<Spec extends Record<string, (...args: readonly any[]) => any>>(
  spec: Spec
): (
  ...args: Parameters<ValueOfRecord<Spec>>
) => { readonly [Key in keyof Spec]: ReturnType<Spec[Key]> };
applySpec<T>(spec: any): (...args: readonly any[]) => T;",
  "assoc": "assoc<T, U, K extends string>(prop: K, val: T, obj: U): Record<K, T> & U;
assoc<T, K extends string>(prop: K, val: T): <U>(obj: U) => Record<K, T> & U;
assoc<K extends string>(prop: K): AssocPartialOne<K>;",
  "assocPath": "assocPath<Output>(path: Path, newValue: any, obj: object): Output;
assocPath<Output>(path: Path, newValue: any): (obj: object) => Output;
assocPath<Output>(path: Path): FunctionToolbelt.Curry<(newValue: any, obj: object) => Output>;",
  "both": "both(pred1: Pred, pred2: Pred): Pred;
both<T>(pred1: Predicate<T>, pred2: Predicate<T>): Predicate<T>;
both<T>(pred1: Predicate<T>): (pred2: Predicate<T>) => Predicate<T>;
both(pred1: Pred): (pred2: Pred) => Pred;",
  "chain": "chain<T, U>(fn: (n: T) => readonly U[], list: readonly T[]): readonly U[];
chain<T, U>(fn: (n: T) => readonly U[]): (list: readonly T[]) => readonly U[];
chain<X0, X1, R>(fn: (x0: X0, x1: X1) => R, fn1: (x1: X1) => X0): (x1: X1) => R;",
  "clamp": "clamp(min: number, max: number, input: number): number;
clamp(min: number, max: number): (input: number) => number;",
  "clone": "clone<T>(input: T): T;
clone<T>(input: readonly T[]): readonly T[];",
  "complement": "complement<T extends readonly any[]>(pred: (...args: T) => boolean): (...args: T) => boolean;",
  "compose": "compose<T1>(fn0: () => T1): () => T1;
compose<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;
compose<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;
compose<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;

compose<T1, T2>(fn1: (x: T1) => T2, fn0: () => T1): () => T2;
compose<V0, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0) => T1): (x0: V0) => T2;
compose<V0, V1, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T2;
compose<V0, V1, V2, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T2;

compose<T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T3;
compose<V0, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T3;
compose<V0, V1, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T3;
compose<V0, V1, V2, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T3;

compose<T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T4;
compose<V0, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T4;
compose<V0, V1, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T4;
compose<V0, V1, V2, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T4;

compose<T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T5;
compose<V0, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T5;
compose<V0, V1, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T5;
compose<V0, V1, V2, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T5;

compose<T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T6;
compose<V0, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T6;
compose<V0, V1, T1, T2, T3, T4, T5, T6>(
  fn5: (x: T5) => T6,
  fn4: (x: T4) => T5,
  fn3: (x: T3) => T4,
  fn2: (x: T2) => T3,
  fn1: (x: T1) => T2,
  fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T6;
compose<V0, V1, V2, T1, T2, T3, T4, T5, T6>(
  fn5: (x: T5) => T6,
  fn4: (x: T4) => T5,
  fn3: (x: T3) => T4,
  fn2: (x: T2) => T3,
  fn1: (x: T1) => T2,
  fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T6;",
  "concat": "concat<T>(x: readonly T[], y: readonly T[]): readonly T[];
concat<T>(x: readonly T[]): (y: readonly T[]) => readonly T[];
concat(x: string, y: string): string;
concat(x: string): (y: string) => string;",
  "cond": "cond(conditions: readonly (readonly [Pred, (...a: readonly any[]) => any])[]): (...x: readonly any[]) => any;
cond<A, B>(conditions: readonly (readonly [SafePred<A>, (...a: readonly A[]) => B])[]): (...x: readonly A[]) => B;",
  "converge": "converge(after: ((...a: readonly any[]) => any), fns: ReadonlyArray<((...x: readonly any[]) => any)>): (...y: readonly any[]) => any;",
  "curry": "curry(fn: (...args: readonly any[]) => any): (...a: readonly any[]) => any;",
  "curryN": "curryN(length: number, fn: (...args: readonly any[]) => any): (...a: readonly any[]) => any;",
  "dec": "dec(x: number): number;",
  "defaultTo": "defaultTo<T>(defaultValue: T): (...inputArguments: readonly (T | null | undefined)[]) => T;
defaultTo<T>(defaultValue: T, ...inputArguments: readonly (T | null | undefined)[]): T;
defaultTo<T, U>(defaultValue: T | U, ...inputArguments: readonly (T | U | null | undefined)[]): T | U;",
  "difference": "difference<T>(a: readonly T[], b: readonly T[]): readonly T[];
difference<T>(a: readonly T[]): (b: readonly T[]) => readonly T[];",
  "dissoc": "dissoc<T>(prop: string, obj: any): T;
dissoc<T>(prop: string): (obj: any) => T;",
  "divide": "divide(x: number, y: number): number;
divide(x: number): (y: number) => number;",
  "drop": "drop<T>(howMany: number, input: readonly T[]): readonly T[];
drop(howMany: number, input: string): string;
drop<T>(howMany: number): {
  <T>(input: readonly T[]): readonly T[];
  (input: string): string;
};",
  "dropLast": "dropLast<T>(howMany: number, input: readonly T[]): readonly T[];
dropLast(howMany: number, input: string): string;
dropLast<T>(howMany: number): {
  <T>(input: readonly T[]): readonly T[];
  (input: string): string;
};",
  "dropLastWhile": "dropLastWhile(predicate: (x: string) => boolean, iterable: string): string;
dropLastWhile(predicate: (x: string) => boolean): (iterable: string) => string;
dropLastWhile<T>(predicate: (x: T) => boolean, iterable: readonly T[]): readonly T[];
dropLastWhile<T>(predicate: (x: T) => boolean): <T>(iterable: readonly T[]) => readonly T[];",
  "dropRepeats": "dropRepeats<T>(list: readonly T[]): readonly T[];",
  "dropRepeatsWith": "dropRepeatsWith<T>(predicate: (x: T, y: T) => boolean, list: readonly T[]): readonly T[];
dropRepeatsWith<T>(predicate: (x: T, y: T) => boolean): (list: readonly T[]) => readonly T[];",
  "dropWhile": "dropWhile(fn: Predicate<string>, iterable: string): string;
dropWhile(fn: Predicate<string>): (iterable: string) => string;
dropWhile<T>(fn: Predicate<T>, iterable: readonly T[]): readonly T[];
dropWhile<T>(fn: Predicate<T>): (iterable: readonly T[]) => readonly T[];",
  "either": "either(firstPredicate: Pred, secondPredicate: Pred): Pred;
either<T>(firstPredicate: Predicate<T>, secondPredicate: Predicate<T>): Predicate<T>;
either<T>(firstPredicate: Predicate<T>): (secondPredicate: Predicate<T>) => Predicate<T>;
either(firstPredicate: Pred): (secondPredicate: Pred) => Pred;",
  "endsWith": "endsWith(target: string, str: string): boolean;
endsWith(target: string): (str: string) => boolean;",
  "eqProps": "eqProps<T, U>(prop: string, obj1: T, obj2: U): boolean;
eqProps<P extends string>(prop: P): <T, U>(obj1: Record<P, T>, obj2: Record<P, U>) => boolean;
eqProps<T>(prop: string, obj1: T): <U>(obj2: U) => boolean;",
  "equals": "equals<T>(x: T, y: T): boolean;
equals<T>(x: T): (y: T) => boolean;",
  "evolve": "evolve<T, U>(rules: ReadonlyArray<(x: T) => U>, list: readonly T[]): readonly U[];
evolve<T, U>(rules: ReadonlyArray<(x: T) => U>) : (list: readonly T[]) => readonly U[];
evolve<E extends Evolver, V extends Evolvable<E>>(rules: E, obj: V): Evolve<V, E>;
evolve<E extends Evolver>(rules: E): <V extends Evolvable<E>>(obj: V) => Evolve<V, E>;",
  "filter": "filter<T>(predicate: Predicate<T>): (input: readonly T[]) => readonly T[];
filter<T>(predicate: Predicate<T>, input: readonly T[]): readonly T[];
filter<T, U>(predicate: ObjectPredicate<T>): (x: Dictionary<T>) => Dictionary<T>;
filter<T>(predicate: ObjectPredicate<T>, x: Dictionary<T>): Dictionary<T>;",
  "find": "find<T>(predicate: (x: T) => boolean, list: readonly T[]): T | undefined;
find<T>(predicate: (x: T) => boolean): (list: readonly T[]) => T | undefined;",
  "findIndex": "findIndex<T>(predicate: (x: T) => boolean, list: readonly T[]): number;
findIndex<T>(predicate: (x: T) => boolean): (list: readonly T[]) => number;",
  "findLast": "findLast<T>(fn: (x: T) => boolean, list: readonly T[]): T | undefined;
findLast<T>(fn: (x: T) => boolean): (list: readonly T[]) => T | undefined;",
  "findLastIndex": "findLastIndex<T>(predicate: (x: T) => boolean, list: readonly T[]): number;
findLastIndex<T>(predicate: (x: T) => boolean): (list: readonly T[]) => number;",
  "flatten": "flatten<T>(list: readonly any[]): readonly T[];",
  "flip": "flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult;
flip<F extends (...args: any) => any, P extends FunctionToolbelt.Parameters<F>>(fn: F): FunctionToolbelt.Curry<(...args: ListToolbelt.Merge<readonly [P[1], P[0]], P>) => FunctionToolbelt.Return<F>>;",
  "forEach": "forEach<T>(fn: Iterator<T, void>, list: readonly T[]): readonly T[];
forEach<T>(fn: Iterator<T, void>): (list: readonly T[]) => readonly T[];
forEach<T>(fn: ObjectIterator<T, void>, list: Dictionary<T>): Dictionary<T>;
forEach<T, U>(fn: ObjectIterator<T, void>): (list: Dictionary<T>) => Dictionary<T>;",
  "fromPairs": "fromPairs<V>(listOfPairs: readonly KeyValuePair<string, V>[]): { readonly [index: string]: V };
fromPairs<V>(listOfPairs: readonly KeyValuePair<number, V>[]): { readonly [index: number]: V };",
  "groupBy": "groupBy<T>(groupFn: (x: T) => string, list: readonly T[]): { readonly [index: string]: readonly T[] };
groupBy<T>(groupFn: (x: T) => string): (list: readonly T[]) => { readonly [index: string]: readonly T[] };",
  "groupWith": "groupWith<T>(compareFn: (x: T, y: T) => boolean): (input: readonly T[]) => readonly (readonly T[])[];
groupWith<T>(compareFn: (x: T, y: T) => boolean, input: readonly T[]): readonly (readonly T[])[];
groupWith<T>(compareFn: (x: T, y: T) => boolean, input: string): readonly string[];",
  "has": "has<T>(prop: string, obj: T): boolean;
has(prop: string): <T>(obj: T) => boolean;",
  "hasPath": "hasPath<T>(
  path: string | readonly string[],
  input: object
): boolean;
hasPath<T>(
  path: string | readonly string[]
): (input: object) => boolean;",
  "head": "head<T>(input: readonly T[]): T | undefined;
head(input: string): string;",
  "identical": "identical<T>(x: T, y: T): boolean;
identical<T>(x: T): (y: T) => boolean;",
  "identity": "identity<T>(input: T): T;",
  "ifElse": "ifElse<T, U>(
  condition: (x: T) => boolean, 
  onTrue: (x: T) => U, 
  onFalse: (x: T) => U, 
): (x: T) => U;
ifElse<T, K, U>(
  condition: (x: T, y: K) => boolean, 
  onTrue: (x: T, y: K) => U, 
  onFalse: (x: T, y: K) => U, 
): (x: T, y: K) => U;",
  "inc": "inc(x: number): number;",
  "includes": "includes(valueToFind: string, input: readonly string[] | string): boolean;
includes(valueToFind: string): (input: readonly string[] | string) => boolean;
includes<T>(valueToFind: T, input: readonly T[]): boolean;
includes<T>(valueToFind: T): (input: readonly T[]) => boolean;",
  "indexBy": "indexBy<T, K extends string | number = string>(condition: (key: T) => K, list: readonly T[]): { readonly [key in K]: T };
indexBy<T, K extends string | number | undefined = string>(condition: (key: T) => K, list: readonly T[]): { readonly [key in NonNullable<K>]?: T };
indexBy<T, K extends string | number = string>(condition: (key: T) => K): (list: readonly T[]) => { readonly [key in K]: T };
indexBy<T, K extends string | number | undefined = string>(condition: (key: T) => K | undefined): (list: readonly T[]) => { readonly [key in NonNullable<K>]?: T };
indexBy<T>(condition: string, list: readonly T[]): { readonly [key: string]: T };
indexBy<T>(condition: string): (list: readonly T[]) => { readonly [key: string]: T };",
  "indexOf": "indexOf<T>(valueToFind: T, list: readonly T[]): number;
indexOf<T>(valueToFind: T): (list: readonly T[]) => number;",
  "init": "init<T>(input: readonly T[]): readonly T[];
init(input: string): string;",
  "intersection": "intersection<T>(listA: readonly T[], listB: readonly T[]): readonly T[];
intersection<T>(listA: readonly T[]): (listB: readonly T[]) => readonly T[];",
  "intersperse": "intersperse<T>(separator: T, list: readonly T[]): readonly T[];
intersperse<T>(separator: T): (list: readonly T[]) => readonly T[];",
  "is": "is(targetPrototype: any, x: any): boolean;
is(targetPrototype: any): (x: any) => boolean;",
  "isEmpty": "isEmpty<T>(x: T): boolean;",
  "isNil": "isNil(x: any): x is null | undefined;",
  "join": "join<T>(glue: string, list: readonly T[]): string;
join<T>(glue: string): (list: readonly T[]) => string;",
  "keys": "keys<T extends object>(x: T): readonly (keyof T)[];
keys<T>(x: T): readonly string[];",
  "last": "last(str: string): string;
last(emptyList: readonly []): undefined;
last<T extends any>(list: readonly T[]): T;",
  "lastIndexOf": "lastIndexOf<T>(target: T, list: readonly T[]): number;
lastIndexOf<T>(target: T): (list: readonly T[]) => number;",
  "length": "length<T>(input: readonly T[]): number;",
  "lens": "lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;",
  "lensIndex": "lensIndex(index: number): Lens;",
  "lensPath": "lensPath(path: RamdaPath): Lens;
lensPath(path: string): Lens;",
  "lensProp": "lensProp(prop: string): {
  <T, U>(obj: T): U;
  set<T, U, V>(val: T, obj: U): V;
};",
  "map": "map<T, U>(fn: ObjectIterator<T, U>, iterable: Dictionary<T>): Dictionary<U>;
map<T, U>(fn: Iterator<T, U>, iterable: readonly T[]): readonly U[];
map<T, U>(fn: Iterator<T, U>): (iterable: readonly T[]) => readonly U[];
map<T, U, S>(fn: ObjectIterator<T, U>): (iterable: Dictionary<T>) => Dictionary<U>;
map<T>(fn: Iterator<T, T>): (iterable: readonly T[]) => readonly T[];
map<T>(fn: Iterator<T, T>, iterable: readonly T[]): readonly T[];",
  "match": "match(regExpression: RegExp, str: string): readonly string[];
match(regExpression: RegExp): (str: string) => readonly string[];",
  "mathMod": "mathMod(x: number, y: number): number;
mathMod(x: number): (y: number) => number;",
  "max": "max<T extends Ord>(x: T, y: T): T;
max<T extends Ord>(x: T): (y: T) => T;",
  "maxBy": "maxBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T;
maxBy<T>(compareFn: (input: T) => Ord, x: T): (y: T) => T;
maxBy<T>(compareFn: (input: T) => Ord): FunctionToolbelt.Curry<(x: T, y: T) => T>;",
  "mean": "mean(list: readonly number[]): number;",
  "median": "median(list: readonly number[]): number;",
  "merge": "merge<O1 extends object, O2 extends object>(target: O1, newProps: O2): Merge<O2, O1, 'flat'>;
merge<O1 extends object>(target: O1): <O2 extends object>(newProps: O2) => Merge<O2, O1, 'flat'>;",
  "mergeAll": "mergeAll<T>(list: readonly object[]): T;
mergeAll(list: readonly object[]): object;",
  "mergeDeepRight": "mergeDeepRight<O1 extends object, O2 extends object>(x: O1, y: O2): Merge<O2, O1, 'deep'>;
mergeDeepRight<O1 extends object>(x: O1): <O2 extends object>(y: O2) => Merge<O2, O1, 'deep'>;",
  "mergeLeft": "mergeLeft<O1 extends object, O2 extends object>(target: O1, newProps: O2): Merge<O2, O1, 'flat'>;
mergeLeft<O1 extends object>(target: O1): <O2 extends object>(newProps: O2) => Merge<O2, O1, 'flat'>;",
  "min": "min<T extends Ord>(x: T, y: T): T;
min<T extends Ord>(x: T): (y: T) => T;",
  "minBy": "minBy<T>(compareFn: (input: T) => Ord, x: T, y: T): T;
minBy<T>(compareFn: (input: T) => Ord, x: T): (y: T) => T;
minBy<T>(compareFn: (input: T) => Ord): FunctionToolbelt.Curry<(x: T, y: T) => T>;",
  "modulo": "modulo(x: number, y: number): number;
modulo(x: number): (y: number) => number;",
  "move": "move<T>(fromIndex: number, toIndex: number, list: readonly T[]): readonly T[];
move(fromIndex: number, toIndex: number): <T>(list: readonly T[]) => readonly T[];
move(fromIndex: number): {
    <T>(toIndex: number, list: readonly T[]): readonly T[];
    (toIndex: number): <T>(list: readonly T[]) => readonly T[];
};",
  "multiply": "multiply(x: number, y: number): number;
multiply(x: number): (y: number) => number;",
  "negate": "negate(x: number): number;",
  "none": "none<T>(predicate: (x: T) => boolean, list: readonly T[]): boolean;
none<T>(predicate: (x: T) => boolean): (list: readonly T[]) => boolean;",
  "not": "not(input: any): boolean;",
  "nth": "nth<T>(index: number, list: readonly T[]): T | undefined;	
nth(index: number): <T>(list: readonly T[]) => T | undefined;",
  "of": "of<T>(x: T): readonly T[];",
  "omit": "omit<T, K extends string>(propsToOmit: readonly K[], obj: T): Omit<T, K>;
omit<K extends string>(propsToOmit: readonly K[]): <T>(obj: T) => Omit<T, K>;
omit<T, U>(propsToOmit: string, obj: T): U;
omit<T, U>(propsToOmit: string): (obj: T) => U;
omit<T>(propsToOmit: string, obj: object): T;
omit<T>(propsToOmit: string): (obj: object) => T;",
  "once": "once<T extends (...args: readonly any[]) => any>(func: T): T;",
  "or": "or<T, U>(a: T, b: U): T | U;
or<T>(a: T): <U>(b: U) => T | U;",
  "over": "over<T>(lens: Lens, fn: Arity1Fn, value: T): T;
over<T>(lens: Lens, fn: Arity1Fn, value: readonly T[]): readonly T[];
over(lens: Lens, fn: Arity1Fn): <T>(value: T) => T;
over(lens: Lens, fn: Arity1Fn): <T>(value: readonly T[]) => readonly T[];
over(lens: Lens): <T>(fn: Arity1Fn, value: T) => T;
over(lens: Lens): <T>(fn: Arity1Fn, value: readonly T[]) => readonly T[];",
  "partial": "partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, args: readonly [V0]): (x1: V1) => T;
partial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: readonly [V0, V1]): (x2: V2) => T;
partial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: readonly [V0]): (x1: V1, x2: V2) => T;
partial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: readonly [V0, V1, V2]): (x2: V3) => T;
partial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: readonly [V0, V1]): (x2: V2, x3: V3) => T;
partial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: readonly [V0]): (x1: V1, x2: V2, x3: V3) => T;
partial<T>(fn: (...a: readonly any[]) => T, args: readonly any[]): (...x: readonly any[]) => T;",
  "partition": "partition<T>(
  predicate: Predicate<T>,
  input: readonly T[]
): readonly [readonly T[], readonly T[]];
partition<T>(
  predicate: Predicate<T>
): (input: readonly T[]) => readonly [readonly T[], readonly T[]];
partition<T>(
  predicate: (x: T, prop?: string) => boolean,
  input: { readonly [key: string]: T}
): readonly [{ readonly [key: string]: T}, { readonly [key: string]: T}];
partition<T>(
  predicate: (x: T, prop?: string) => boolean
): (input: { readonly [key: string]: T}) => readonly [{ readonly [key: string]: T}, { readonly [key: string]: T}];",
  "path": "path<Input, T>(pathToSearch: Path, obj: Input): T | undefined;
path<T>(pathToSearch: Path, obj: any): T | undefined;
path<T>(pathToSearch: Path): (obj: any) => T | undefined;
path<Input, T>(pathToSearch: Path): (obj: Input) => T | undefined;",
  "pathEq": "pathEq(pathToSearch: Path, target: any, input: any): boolean;
pathEq(pathToSearch: Path, target: any): (input: any) => boolean;
pathEq(pathToSearch: Path): FunctionToolbelt.Curry<(a: any, b: any) => boolean>;",
  "pathOr": "pathOr<T>(defaultValue: T, pathToSearch: Path, obj: any): T;
pathOr<T>(defaultValue: T, pathToSearch: Path): (obj: any) => T;
pathOr<T>(defaultValue: T): FunctionToolbelt.Curry<(a: Path, b: any) => T>;",
  "paths": "paths<Input, T>(pathsToSearch: readonly Path[], obj: Input): readonly (T | undefined)[];
paths<Input, T>(pathsToSearch: readonly Path[]): (obj: Input) => readonly (T | undefined)[];
paths<T>(pathsToSearch: readonly Path[], obj: any): readonly (T | undefined)[];
paths<T>(pathsToSearch: readonly Path[]): (obj: any) => readonly (T | undefined)[];",
  "pick": "pick<T, K extends string | number | symbol>(propsToPick: readonly K[], input: T): Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;
pick<K extends string | number | symbol>(propsToPick: readonly K[]): <T>(input: T) => Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;
pick<T, U>(propsToPick: string, input: T): U;
pick<T, U>(propsToPick: string): (input: T) => U;
pick<T>(propsToPick: string, input: object): T;
pick<T>(propsToPick: string): (input: object) => T;",
  "pickAll": "pickAll<T, U>(propsToPick: readonly string[], input: T): U;
pickAll<T, U>(propsToPick: readonly string[]): (input: T) => U;
pickAll<T, U>(propsToPick: string, input: T): U;
pickAll<T, U>(propsToPick: string): (input: T) => U;",
  "pipe": "pipe<T1>(fn0: () => T1): () => T1;
pipe<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;
pipe<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;
pipe<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;

pipe<T1, T2>(fn0: () => T1, fn1: (x: T1) => T2): () => T2;
pipe<V0, T1, T2>(fn0: (x0: V0) => T1, fn1: (x: T1) => T2): (x0: V0) => T2;
pipe<V0, V1, T1, T2>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1) => T2;
pipe<V0, V1, V2, T1, T2>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1, x2: V2) => T2;

pipe<T1, T2, T3>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): () => T3;
pipe<V0, T1, T2, T3>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x: V0) => T3;
pipe<V0, V1, T1, T2, T3>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1) => T3;
pipe<V0, V1, V2, T1, T2, T3>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1, x2: V2) => T3;

pipe<T1, T2, T3, T4>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): () => T4;
pipe<V0, T1, T2, T3, T4>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x: V0) => T4;
pipe<V0, V1, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1) => T4;
pipe<V0, V1, V2, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1, x2: V2) => T4;

pipe<T1, T2, T3, T4, T5>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): () => T5;
pipe<V0, T1, T2, T3, T4, T5>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x: V0) => T5;
pipe<V0, V1, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1) => T5;
pipe<V0, V1, V2, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1, x2: V2) => T5;

pipe<T1, T2, T3, T4, T5, T6>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): () => T6;
pipe<V0, T1, T2, T3, T4, T5, T6>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x: V0) => T6;
pipe<V0, V1, T1, T2, T3, T4, T5, T6>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x0: V0, x1: V1) => T6;
pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6>(
  fn0: (x0: V0, x1: V1, x2: V2) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6): (x0: V0, x1: V1, x2: V2) => T6;

pipe<T1, T2, T3, T4, T5, T6, T7>(
  fn0: () => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn: (x: T6) => T7): () => T7;
pipe<V0, T1, T2, T3, T4, T5, T6, T7>(
  fn0: (x: V0) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn: (x: T6) => T7): (x: V0) => T7;
pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7>(
  fn0: (x0: V0, x1: V1) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7): (x0: V0, x1: V1) => T7;
pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7>(
  fn0: (x0: V0, x1: V1, x2: V2) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7): (x0: V0, x1: V1, x2: V2) => T7;

pipe<T1, T2, T3, T4, T5, T6, T7, T8>(
  fn0: () => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn: (x: T7) => T8): () => T8;
pipe<V0, T1, T2, T3, T4, T5, T6, T7, T8>(
  fn0: (x: V0) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn: (x: T7) => T8): (x: V0) => T8;
pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8>(
  fn0: (x0: V0, x1: V1) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8): (x0: V0, x1: V1) => T8;
pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8>(
  fn0: (x0: V0, x1: V1, x2: V2) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8): (x0: V0, x1: V1, x2: V2) => T8;

pipe<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
  fn0: () => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9): () => T9;
pipe<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(
  fn0: (x0: V0) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9): (x0: V0) => T9;
pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8, T9>(
  fn0: (x0: V0, x1: V1) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9): (x0: V0, x1: V1) => T9;
pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8, T9>(
  fn0: (x0: V0, x1: V1, x2: V2) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9): (x0: V0, x1: V1, x2: V2) => T9;

pipe<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
  fn0: () => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9,
  fn9: (x: T9) => T10): () => T10;
pipe<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
  fn0: (x0: V0) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9,
  fn9: (x: T9) => T10): (x0: V0) => T10;
pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
  fn0: (x0: V0, x1: V1) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9,
  fn9: (x: T9) => T10): (x0: V0, x1: V1) => T10;
pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
  fn0: (x0: V0, x1: V1, x2: V2) => T1,
  fn1: (x: T1) => T2,
  fn2: (x: T2) => T3,
  fn3: (x: T3) => T4,
  fn4: (x: T4) => T5,
  fn5: (x: T5) => T6,
  fn6: (x: T6) => T7,
  fn7: (x: T7) => T8,
  fn8: (x: T8) => T9,
  fn9: (x: T9) => T10): (x0: V0, x1: V1, x2: V2) => T10;",
  "pluck": "pluck<K extends keyof T, T>(property: K, list: readonly T[]): ReadonlyArray<T[K]>;
pluck<T>(property: number, list: ReadonlyArray<{ readonly [k: number]: T }>): readonly T[];
pluck<P extends string>(property: P): <T>(list: ReadonlyArray<Record<P, T>>) => readonly T[];
pluck(property: number): <T>(list: ReadonlyArray<{ readonly [k: number]: T }>) => readonly T[];",
  "prepend": "prepend<T>(x: T, input: readonly T[]): readonly T[];
prepend<T>(x: T): (input: readonly T[]) => readonly T[];",
  "product": "product(list: readonly number[]): number;",
  "prop": "prop<P extends keyof T, T>(propToFind: P, obj: T): T[P];
prop<P extends string | number>(p: P): <T>(propToFind: Record<P, T>) => T;
prop<P extends keyof T, T>(p: P): (propToFind: Record<P, T>) => T;",
  "propEq": "propEq<K extends string | number>(propToFind: K, valueToMatch: any, obj: Record<K, any>): boolean;
propEq<K extends string | number>(propToFind: K, valueToMatch: any): (obj: Record<K, any>) => boolean;
propEq<K extends string | number>(propToFind: K): {
  (valueToMatch: any, obj: Record<K, any>): boolean;
  (valueToMatch: any): (obj: Record<K, any>) => boolean;
};",
  "propIs": "propIs(type: any, name: string, obj: any): boolean;
propIs(type: any, name: string): (obj: any) => boolean;
propIs(type: any): {
    (name: string, obj: any): boolean;
    (name: string): (obj: any) => boolean;
};",
  "propOr": "propOr<T, P extends string>(defaultValue: T, property: P, obj: Partial<Record<P, T>> | undefined): T;
propOr<T, P extends string>(defaultValue: T, property: P): (obj: Partial<Record<P, T>> | undefined) => T;
propOr<T>(defaultValue: T): {
  <P extends string>(property: P, obj: Partial<Record<P, T>> | undefined): T;
  <P extends string>(property: P): (obj: Partial<Record<P, T>> | undefined) => T;
}",
  "props": "props<P extends string, T>(propsToPick: readonly P[], obj: Record<P, T>): readonly T[];
props<P extends string>(propsToPick: readonly P[]): <T>(obj: Record<P, T>) => readonly T[];
props<P extends string, T>(propsToPick: readonly P[]): (obj: Record<P, T>) => readonly T[];",
  "range": "range(startInclusive: number, endExclusive: number): readonly number[];
range(startInclusive: number): (endExclusive: number) => readonly number[];",
  "reduce": "reduce<T, TResult>(reducer: (prev: TResult, current: T, i: number) => TResult, initialValue: TResult, list: readonly T[]): TResult;
reduce<T, TResult>(reducer: (prev: TResult, current: T) => TResult, initialValue: TResult, list: readonly T[]): TResult;
reduce<T, TResult>(reducer: (prev: TResult, current: T, i?: number) => TResult): (initialValue: TResult, list: readonly T[]) => TResult;
reduce<T, TResult>(reducer: (prev: TResult, current: T, i?: number) => TResult, initialValue: TResult): (list: readonly T[]) => TResult;",
  "reject": "reject<T>(predicate: Predicate<T>, list: readonly T[]): readonly T[];
reject<T>(predicate: Predicate<T>): (list: readonly T[]) => readonly T[];
reject<T>(predicate: Predicate<T>, obj: Dictionary<T>): Dictionary<T>;
reject<T, U>(predicate: Predicate<T>): (obj: Dictionary<T>) => Dictionary<T>;",
  "repeat": "repeat<T>(x: T): (timesToRepeat: number) => readonly T[];
repeat<T>(x: T, timesToRepeat: number): readonly T[];",
  "replace": "replace(strOrRegex: RegExp | string, replacer: string, str: string): string;
replace(strOrRegex: RegExp | string, replacer: string): (str: string) => string;
replace(strOrRegex: RegExp | string): (replacer: string) => (str: string) => string;",
  "reverse": "reverse<T>(input: readonly T[]): readonly T[];
reverse(input: string): string;",
  "set": "set<T, U>(lens: Lens, replacer: U, obj: T): T;
set<U>(lens: Lens, replacer: U): <T>(obj: T) => T;
set(lens: Lens): <T, U>(replacer: U, obj: T) => T;",
  "slice": "slice(from: number, to: number, input: string): string;
slice<T>(from: number, to: number, input: readonly T[]): readonly T[];
slice(from: number, to: number): {
  (input: string): string;
  <T>(input: readonly T[]): readonly T[];
};
slice(from: number): {
  (to: number, input: string): string;
  <T>(to: number, input: readonly T[]): readonly T[];
};",
  "sort": "sort<T>(sortFn: (a: T, b: T) => number, list: readonly T[]): readonly T[];
sort<T>(sortFn: (a: T, b: T) => number): (list: readonly T[]) => readonly T[];",
  "sortBy": "sortBy<T>(sortFn: (a: T) => Ord, list: readonly T[]): readonly T[];
sortBy(sortFn: (a: any) => Ord): <T>(list: readonly T[]) => readonly T[];",
  "split": "split(separator: string | RegExp): (str: string) => readonly string[];
split(separator: string | RegExp, str: string): readonly string[];",
  "splitAt": "splitAt<T>(index: number, input: readonly T[]): readonly [readonly T[], readonly T[]];
splitAt(index: number, input: string): readonly [string, string];
splitAt(index: number): {
    <T>(input: readonly T[]): readonly [readonly T[], readonly T[]];
    (input: string): readonly [string, string];
};",
  "splitEvery": "splitEvery<T>(sliceLength: number, input: readonly T[]): readonly (readonly T[])[];
splitEvery(sliceLength: number, input: string): readonly string[];
splitEvery(sliceLength: number): {
  (input: string): readonly string[];
  <T>(input: readonly T[]): readonly (readonly T[])[];
};",
  "splitWhen": "splitWhen<T, U>(predicate: Predicate<T>, list: readonly U[]): readonly (readonly U[])[];
splitWhen<T>(predicate: Predicate<T>): <U>(list: readonly U[]) => readonly (readonly U[])[];",
  "startsWith": "startsWith(target: string, str: string): boolean;
startsWith(target: string): (str: string) => boolean;",
  "subtract": "subtract(x: number, y: number): number;
subtract(x: number): (y: number) => number;",
  "sum": "sum(list: readonly number[]): number;",
  "symmetricDifference": "symmetricDifference<T>(x: readonly T[], y: readonly T[]): readonly T[];
symmetricDifference<T>(x: readonly T[]): <T>(y: readonly T[]) => readonly T[];",
  "tail": "tail<T>(input: readonly T[]): readonly T[];
tail(input: string): string;",
  "take": "take<T>(howMany: number, input: readonly T[]): readonly T[];
take(howMany: number, input: string): string;
take<T>(howMany: number): {
  <T>(input: readonly T[]): readonly T[];
  (input: string): string;
};",
  "takeLast": "takeLast<T>(howMany: number, input: readonly T[]): readonly T[];
takeLast(howMany: number, input: string): string;
takeLast<T>(howMany: number): {
  <T>(input: readonly T[]): readonly T[];
  (input: string): string;
};",
  "takeLastWhile": "takeLastWhile(predicate: (x: string) => boolean, input: string): string;
takeLastWhile(predicate: (x: string) => boolean): (input: string) => string;
takeLastWhile<T>(predicate: (x: T) => boolean, input: readonly T[]): readonly T[];
takeLastWhile<T>(predicate: (x: T) => boolean): <T>(input: readonly T[]) => readonly T[];",
  "takeWhile": "takeWhile(fn: Predicate<string>, iterable: string): string;
takeWhile(fn: Predicate<string>): (iterable: string) => string;
takeWhile<T>(fn: Predicate<T>, iterable: readonly T[]): readonly T[];
takeWhile<T>(fn: Predicate<T>): (iterable: readonly T[]) => readonly T[];",
  "tap": "tap<T>(fn: (x: T) => void, input: T): T;
tap<T>(fn: (x: T) => void): (input: T) => T;",
  "test": "test(regExpression: RegExp): (str: string) => boolean;
test(regExpression: RegExp, str: string): boolean;",
  "times": "times<T>(fn: (i: number) => T, howMany: number): readonly T[];
times<T>(fn: (i: number) => T): (howMany: number) => readonly T[];",
  "toLower": "toLower(str: string): string;",
  "toPairs": "toPairs<S>(obj: { readonly [k: string]: S } | { readonly [k: number]: S }): readonly (readonly [string, S])[];",
  "toString": "toString<T>(x: T): string;",
  "toUpper": "toUpper(str: string): string;",
  "transpose": "transpose<T>(list: readonly (readonly T[])[]): readonly (readonly T[])[];",
  "trim": "trim(str: string): string;",
  "tryCatch": "tryCatch<T, U>(
  fn: (input: T) => U,
  fallback: U
): (input: T) => U;
tryCatch<T, U>(
  fn: (input: T) => U,
  fallback: (input: T) => U
): (input: T) => U;
tryCatch<T>(
  fn: (input: any) => Promise<any>,
  fallback: T
): (input: any) => Promise<T>;
tryCatch<T>(
  fn: (input: any) => Promise<any>,
  fallback: (input: any) => Promise<any>,
): (input: any) => Promise<T>;",
  "type": "type(x: any): RambdaTypes;",
  "union": "union<T>(x: readonly T[], y: readonly T[]): readonly T[];
union<T>(x: readonly T[]): (y: readonly T[]) => readonly T[];",
  "uniq": "uniq<T>(list: readonly T[]): readonly T[];",
  "uniqWith": "uniqWith<T, U>(uniqFn: (x: T, y: T) => boolean, list: readonly T[]): readonly T[];
uniqWith<T, U>(uniqFn: (x: T, y: T) => boolean): (list: readonly T[]) => readonly T[];",
  "unless": "unless<T, U>(predicate: (x: T) => boolean, whenFalseFn: (x: T) => U, obj: T): U;
unless<T, U>(predicate: (x: T) => boolean, whenFalseFn: (x: T) => U): (obj: T) => U;",
  "update": "update<T>(index: number, newValue: T, list: readonly T[]): readonly T[];
update<T>(index: number, newValue: T): (list: readonly T[]) => readonly T[];",
  "values": "values<T extends object, K extends keyof T>(obj: T): readonly T[K][];",
  "view": "view<T, U>(lens: Lens): (target: T) => U;
view<T, U>(lens: Lens, target: T): U;",
  "when": "when<T, U>(predicate: (x: T) => boolean, whenTrueFn: (a: T) => U, input: T): T | U;
when<T, U>(predicate: (x: T) => boolean, whenTrueFn: (a: T) => U): (input: T) => T | U;
when<T, U>(predicate: (x: T) => boolean): FunctionToolbelt.Curry<(whenTrueFn: (a: T) => U, input: T) => T | U>;",
  "where": "where<T, U>(conditions: T, input: U): boolean;
where<T>(conditions: T): <U>(input: U) => boolean;
where<ObjFunc2, U>(conditions: ObjFunc2, input: U): boolean;
where<ObjFunc2>(conditions: ObjFunc2): <U>(input: U) => boolean;",
  "whereEq": "whereEq<T, U>(condition: T, input: U): boolean;
whereEq<T>(condition: T): <U>(input: U) => boolean;",
  "without": "without<T>(matchAgainst: readonly T[], source: readonly T[]): readonly T[];
without<T>(matchAgainst: readonly T[]): (source: readonly T[]) => readonly T[];",
  "xor": "xor(x: boolean, y: boolean): boolean;
xor(y: boolean): (y: boolean) => boolean;",
  "zip": "zip<K, V>(x: readonly K[], y: readonly V[]): readonly KeyValuePair<K, V>[];
zip<K>(x: readonly K[]): <V>(y: readonly V[]) => readonly KeyValuePair<K, V>[];",
  "zipObj": "zipObj<T, K extends string>(keys: readonly K[], values: readonly T[]): { readonly [P in K]: T };
zipObj<K extends string>(keys: readonly K[]): <T>(values: readonly T[]) => { readonly [P in K]: T };
zipObj<T, K extends number>(keys: readonly K[], values: readonly T[]): { readonly [P in K]: T };
zipObj<K extends number>(keys: readonly K[]): <T>(values: readonly T[]) => { readonly [P in K]: T };",
  "zipWith": "zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: readonly T[], list2: readonly U[]): readonly TResult[];
zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: readonly T[]): (list2: readonly U[]) => readonly TResult[];
zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult): (list1: readonly T[], list2: readonly U[]) => readonly TResult[];",
}
`;
